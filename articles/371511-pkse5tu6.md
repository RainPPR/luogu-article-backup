---
title: 题解：AT_abc366_e [ABC366E] Manhattan Multifocal Ellipse
date: 1723721456
description: 我们将，  defabs1leftlvert1rightrvert sumi1nleftabsxxiabsyyiright  拆为，  defabs1leftl
author: 371511
---

我们将，

$$
\def\abs#1{\left\lvert{#1}\right\rvert}
\sum_{i=1}^n\left(\abs{x-x_i}+\abs{y-y_i}\right)
$$

拆为，

$$
\def\abs#1{\left\lvert{#1}\right\rvert}
\sum_{i=1}^n\abs{x-x_i}+\sum_{i=1}^n\abs{y-y_i}
$$

设，

$$
\def\abs#1{\left\lvert{#1}\right\rvert}
F(x)=\sum_{i=1}^n\abs{x-x_i}
$$

$$
\def\abs#1{\left\lvert{#1}\right\rvert}
G(y)=\sum_{i=1}^n\abs{y-y_i}
$$

问题即求满足，

$$
F(x)+G(y)\le D
$$

的点对 $x$ 数量。

---

考虑两边分别处理，假设我们已经求出了 $F,G$ 的值。

我们枚举每一个 $x$，那么就知道了 $F(x)$，然后考虑另一侧，

问题转化为，求满足，

$$
G(y)-D\le-F(x)
$$

的 $y$ 的数量。

我们可以在预处理 $G(x)$ 的时候，将 $G(y)-D$ 扔到 `vector` 里 `lower_bound` 即可。

那么这个问题就很简单了。

---

然后考虑求 $F(x),G(y)$ 的值。

发现绝对值不好处理，于是应用经典方法，拆绝对值，

$$
\def\sub#1{\left({#1}\right)}
F(x)=\sum_{i=1}^n\sub{x-x_i}[x_i\le x]+\sum_{i=1}^n\sub{x_i-x}[x_i>x]
$$

我们提前将所有的 $x_i$ 升序排序，设 $P(x)$ 表示最后一个 $x_i\le x$ 的 $i$，

$$
\def\sub#1{\left({#1}\right)}
F(x)=\sum_{i=1}^{P(x)}\sub{x-x_i}+\sum_{i=P(x)+1}^n\sub{x_i-x}
$$

将合式拆开，

$$
\def\sub#1{\left({#1}\right)}
F(x)=\sub{xP(x)-\sum_{i=1}^{P(x)}x_i}+\sub{\sum_{i=P(x)+1}^nx_i-nx+xP(x)}
$$

整理得，

$$
\def\sub#1{\left({#1}\right)}
F(x)=\sum_{i=P(x)+1}^nx_i-\sum_{i=1}^{P(x)}x_i-nx+2xP(x)
$$

设 $S_i$ 为 $x_i$ 的前缀和，即，

$$
S_i=\sum_{j=1}^ix_j
$$

那么，

$$
\def\sub#1{\left({#1}\right)}
F(x)=S_n-2S_{P(x)}-nx+2xP(x)
$$

容易发现 $P(x)$ 可以二分得到，而前面部分直接前缀和解决。

我们可以类似的求出 $G(y)$ 的值，问题解决。

---

代码：

```cpp
using ll = long long;

constexpr int N = 2e5 + 10;
constexpr int V = 2e6 + 10;

int n, D;

int X[N], Y[N];
ll F[2 * V + 10], G[2 * V + 10];
ll S[2 * V + 10], T[2 * V + 10];
int P[2 * V + 10], Q[2 * V + 10];

void calc(int *x, ll *s, ll *f, int *p) {
	sort(x + 1, x + n + 1);
	for (int i = -V; i <= V; ++i)
		p[i + V] = upper_bound(x + 1, x + n + 1, i) - 1 - x;
	for (int i = 1; i <= n; ++i)
		s[i] = x[i] + s[i - 1];
	for (int i = -V; i <= V; ++i)
		f[i + V] = s[n] - 2 * s[p[i + V]] - 1ll * n * i + 2ll * i * p[i + V];
}

void Main() {
	cin >> n >> D;
	for (int i = 1; i <= n; ++i)
		cin >> X[i] >> Y[i];
	calc(X, S, F, P);
	calc(Y, T, G, Q);
	vector<ll> bucket;
	bucket.reserve(2 * V);
	for (int y = -V; y <= V; ++y)
		bucket.push_back(G[y + V] - D);
	sort(bucket.begin(), bucket.end());
	ll ans = 0;
	for (int x = -V; x <= V; ++x)
		ans += upper_bound(bucket.begin(), bucket.end(), -F[x + V]) - bucket.begin();
	cout << ans << endl;
}
```

注意可能的点的坐标有可能超过 $10^6$，直接开到 $2\times10^6$ 即可。
