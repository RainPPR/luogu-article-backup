---
title: 题解：AT_abc354_e [ABC354E] Remove Pairs
date: 1716118471
description: 注意到 Nle18，这是我们最不喜欢的数据范围：状态压缩。 直接开始猜状态设计，设，  Fe01  表示现在仅剩 e 集合中的牌，先手、后手是否可以获胜。 容易发现，我们取走一张牌后： 如果下一步的人必败，则这一
author: 371511
---

注意到 $N\le18$，这是我们最~~不~~喜欢的数据范围：状态压缩。

直接开始猜状态设计，设，

$$
F(e,0/1)
$$

表示现在仅剩 $e$ 集合中的牌，先手、后手是否可以获胜。

容易发现，我们取走一张牌后：

如果下一步的人必败，则这一步的人必胜，因为可以走这个状态。

反之，这个人必败。

过于板子的状压 DP 了，具体的转移见下面代码。

复杂度为 $\mathcal O(2^nn^2)$，其中 $2^n$ 为集合数量，$n^2$ 为转移复杂度。

因为状压不好写，于是进行记忆化搜索，这道题没有卡掉，因此可用。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

struct emm { int a, b; };

int n; vector<emm> a;

int mem[2][(1 << 18) + 5];

int solev(int e, int op) {
    if (mem[op][e] != -1) return mem[op][e];
    for (int i = 0; i < n; ++i) {
        if (!(e & (1 << i))) continue;
        for (int j = i + 1; j < n; ++j) {
            if (!(e & (1 << j))) continue;
            if (a[i].a != a[j].a && a[i].b != a[j].b) continue;
            if (solev(e - (1 << i) - (1 << j), op ^ 1) == 0) return mem[op][e] = 1;
        }
    }
    return mem[op][e] = 0;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin >> n; a.resize(n); memset(mem, -1, sizeof mem);
    for (int i = 0; i < n; ++i) cin >> a[i].a >> a[i].b;
    cout << (solev((1 << n) - 1, 0) ? "Takahashi" : "Aoki") << endl;
    return 0;
}
```
