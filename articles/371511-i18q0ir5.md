---
title: 题解：P11324 【MX-S7-T2】「SMOI-R2」Speaker
date: 1732435453
description: 设 textsonx 表示 x 的儿子集合，钦定以 1 为根。 设 textfax 表示 x 的父亲节点，同样钦定以 1 为根。 设 textpathuv 表示 uto v 路径上所有点
author: 371511
---

设 $\text{son}(x)$ 表示 $x$ 的儿子集合，钦定以 $1$ 为根。

设 $\text{fa(x)}$ 表示 $x$ 的父亲节点，同样钦定以 $1$ 为根。

设 $\text{path}(u,v)$ 表示 $u\to v$ 路径上所有点的集合。

设 $\text{dis}(u,v)$ 表示 $u\to v$ 的路径上所有边的边权和。

注意到查询 $x,y$ 的答案一定可以表示为：

$$
c_x+c_y-\text{dis}(x,y)+\max_{z,p\in\text{path}(x,y)}\{c_z-2\text{dis}(p,z)\}
$$

其中 $z$ 表示第二场演讲所在的城市，$p$ 为 $x\to z,z\to y$ 交点离 $z$ 最远的点。

注意到，此时 $p$ 可能会取到更多的点，但是因为我们取最大值一定能包含最优解的情况，而且其他情况（包含合法但不优的和不合法的）一定不会优于最优解，因此这个公式就是正确的。

不妨设：

$$
f(p)=\max_z\{c_z-2\text{dis}(p,z)\}
$$

则答案表示为：

$$
c_x+c_y-\text{dis}(x,y)+\max_{p\in\text{path}(x,y)}f(p)
$$

可以重链剖分或者倍增求出，现在考虑如何求 $f(p)$。

不妨设 $g(p)$ 表示在 $p$ 的子树中的答案，容易得到转移方程：

$$
g(p)=\max\left\{c_p,\max_{z\in\text{son}_p}\{g(z)-2\text{dis}(p,z)\}\right\}
$$

因此，容易得到 $f(p)$ 的转移方程：

$$
f(p)=\max\{g(p),f(\text{fa}(p))-2\text{dis}(p,\text{fa}(p))\}
$$

这就是换根 DP，直接求解即可，复杂度瓶颈在求路径 $\max$，总时间复杂度为 $\mathcal O(n\log n)$。

代码：

```cpp
constexpr int N = 2e5 + 10;

int n, q, c[N];

struct edge {
	int v, w;
	edge() = default;
	edge(int v, int w): v(v), w(w) {}
};

vector<edge> G[N];

int f[N], g[N];
int dep[N], dis[N];
int fa[N][21], mx[N][21];

void dfs1(int u, int ff) {
	dep[u] = dep[ff] + 1;
	for (int k = 1; k <= 20; ++k)
		fa[u][k] = fa[fa[u][k - 1]][k - 1];
	g[u] = c[u];
	for (auto t : G[u]) {
		int v = t.v, w = t.w;
		if (v == ff)
			continue;
		fa[v][0] = u;
		dis[v] = dis[u] + w;
		dfs1(v, u);
		g[u] = max(g[u], g[v] - 2 * w);
	}
}

void dfs2(int u, int ff, int lt) {
	mx[u][0] = f[u] = max(g[u], f[ff] - 2 * lt);
	for (int k = 1; k <= 20; ++k)
		mx[u][k] = max(mx[u][k - 1], mx[fa[u][k - 1]][k - 1]);
	for (auto t : G[u])
		if (t.v != ff)
			dfs2(t.v, u, t.w);
}

void init() {
	dfs1(1, 0);
	dfs2(1, 0, 0);
}

int lca(int x, int y) {
	if (dep[x] < dep[y])
		swap(x, y);
	for (int k = 20; k >= 0; --k)
		if (dep[fa[x][k]] >= dep[y])
			x = fa[x][k];
	if (x == y)
		return x;
	for (int k = 20; k >= 0; --k)
		if (fa[x][k] != fa[y][k])
			x = fa[x][k], y = fa[y][k];
	return fa[x][0];
}

int path(int x, int y) {
	int res = -1e18;
	if (dep[x] < dep[y])
		swap(x, y);
	for (int k = 20; k >= 0; --k)
		if (dep[fa[x][k]] >= dep[y]) {
			res = max(res, mx[x][k]);
			x = fa[x][k];
		}
	if (x == y)
		return max(res, mx[x][0]);
	for (int k = 20; k >= 0; --k)
		if (fa[x][k] != fa[y][k]) {
			res = max(res, mx[x][k]);
			res = max(res, mx[y][k]);
			x = fa[x][k], y = fa[y][k];
		}
	res = max(res, mx[x][1]);
	res = max(res, mx[y][1]);
	return res;
}

int diss(int x, int y) {
	return dis[x] + dis[y] - 2 * dis[lca(x, y)];
}

int getans(int x, int y) {
	return c[x] + c[y] - diss(x, y) + path(x, y);
}

void Main() {
	read(n, q);
	for (int i = 1; i <= n; ++i)
		read(c[i]);
	for (int i = 2; i <= n; ++i) {
		int u, v, w;
		read(u, v, w);
		G[u].emplace_back(v, w);
		G[v].emplace_back(u, w);
	}
	init();
	while (q--) {
		int x = read<int>();
		int y = read<int>();
		writeln(getans(x, y));
	}
	return;
}
```
