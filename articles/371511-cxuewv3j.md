---
title: CF803F Coprime Subsequences 题解
date: 1706060190
description: httpswwwluogucomcnproblemCF803F 与当前 No 1 题解类似，使用容斥原理，不要莫反。 首先，我们知道，对于长度为 n 的序列，他的子序列共有 2n1 个。 不会这个的请不要看绿题，谢谢
author: 371511
---

<https://www.luogu.com.cn/problem/CF803F>

与当前 No. 1 题解类似，使用容斥原理，不要莫反。

首先，我们知道，对于长度为 $n$ 的序列，他的子序列共有 $2^n-1$ 个。

不会这个的请不要看绿题，谢谢（）

然后我们考虑，这些子序列中，有哪些子序列的 $\gcd$ 不是 $1$ 的。

我们枚举一个 $k$，用 $f(k)$ 表示子序列 $\gcd$ 为 $k$ 的倍数的区间个数，

即定义式：$f(k)  = \sum_{S \in a}[k \mid \gcd(S)]$。

我们发现 $f(k)$ 可以非常简单的计算：

求出所有 $a$ 中，$k$ 的倍数的数的出现次数 $c_k$，$f(k)=2^{c_k}-1$。

然后考虑容斥。为什么要容斥？

显然 $k \mid \gcd(S)$ 显然会包括上其他的 $tk \mid \gcd(S)$（$t\ge2$），答案偏大。

那么我们设 $g(k)$ 表示子序列 $\gcd=k$ 的区间个数。

显然 $g(k)=f(k)-g(2k)-g(3k)-\dots-g(\lambda k)$。

白话：$\gcd$ 是 $k$ 的倍数的子序列个数，减去 $\gcd$ 为 $tk$（$t\ge2$）的子序列个数。

然后考虑实现，显然 $g(k)$ 要用到 $k$ 以后的元素，而 $f$ 与其他 $f$ 无关。

因此可以倒叙遍历 $k$。而 $a_i \le 10^5$，可以用桶实现。

有一个原理叫做一个序列的 $\gcd$ 一定 $\le$ 这个序列的任意一个数。

时间复杂度：$\mathcal{O}(n \log n)$（$n$ 与 $a_i$ 同阶）。

评测记录：<https://www.luogu.com.cn/record/144075059>。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

constexpr int N = 1e5 + 10;
constexpr ll MOD = 1e9 + 7;

int app[N];

ll fac[N], g[N];

inline ll mns(ll a, ll b) {
	return (a - b + MOD) % MOD;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	int n, x; cin >> n;
	for (int i = 0; i < n; ++i) cin >> x, ++app[x];
	fac[0] = 1; for (int i = 1; i <= n; ++i) fac[i] = fac[i - 1] * 2 % MOD;
	for (int i = N - 1; i; --i) {
		int cnt = 0; for (int j = i; j < N; j += i) cnt += app[j];
		g[i] = fac[cnt] - 1;
		for (int j = i + i; j < N; j += i) g[i] = mns(g[i], g[j]);
	} cout << g[1] << endl;
	return 0;
}
```

