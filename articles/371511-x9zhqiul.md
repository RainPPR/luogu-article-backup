---
title: 题解：AT_abc356_d [ABC356D] Masked Popcount
date: 1717250151
description: 数位 DP，非数学做法，没有用到任何数学的东西。

 题目描述

给定 N 和 M，求

sumk0NoperatornamepopcountkoperatornameM

其中， 表示按位与。
author: 371511
---

数位 DP，非数学做法，没有用到任何数学的东西。

### 题目描述

给定 $N$ 和 $M$，求
$$
\sum_{k=0}^N\operatorname{popcount(k\operatorname{\&}M)}
$$
其中，$\&$ 表示按位与。

### 题解

容易想到，我们按位考虑。

从前往后一次对于每一位，如果这一位放了 $1$ 且 $M$ 的这一位也是 $1$，

那么才会对答案有贡献，而且这个贡献数正好是后面所有位的情况总数。

于是，就是数位 DP 的板子题了。

由于是赛时最后十分钟才发现我前面手欠打错了，因此懒得想数学做法，

直接两个数位 DP 似乎也不是不可以哦（

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

using ll = long long;

#define int ll

constexpr int mod = 998244353;

int n, m;

int mem[100], mem2[100];

int dfs2(int pos, int limit) {
    if (pos == -1) return 1;
    if (!limit && mem2[pos] != -1) return mem2[pos];
    int res = 0;
    int up = limit ? ((n >> pos) & 1) : 1;
    for (int i = 0; i <= up; ++i) res += dfs2(pos - 1, limit && (i == up));
    if (!limit) mem2[pos] = res;
    return res;
}

int dfs(int pos, int limit) {
    if (pos == -1) return 0;
    if (!limit && mem[pos] != -1) return mem[pos];
    int res = 0;
    int up = limit ? ((n >> pos) & 1) : 1;
    for (int i = 0; i <= up; ++i) {
        res = (res + dfs(pos - 1, limit && (i == up))) % mod;
        if (i && ((m >> pos) & 1)) res = (res + dfs2(pos - 1, limit && (i == up))) % mod;
    }
    if (!limit) mem[pos] = res;
    return res;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin >> n >> m;
    memset(mem, -1, sizeof mem);
    memset(mem2, -1, sizeof mem2);
    cout << dfs(61, 1) << endl;
    return 0;
}
```

下面所说的位，从最高位下标递减，

其中，`mem2` 对应的 `dfs2`，表示从 `pos` 位开始填充，是否收到限制（`limit`）的总情况数。

枚举每一位的最大值 `up`，对应直接加即可，注意到这个答案和 $N$ 是一个级别的，因此就不取模了。

另外，`mem` 对应的 `dfs`，表示从 `pos` 位开始填充，是否收到限制（`limit`）的答案。

注意到我们只需要考虑 `pos` 位及以后的（前面的交给搜索到它的时候去考虑），

因此，如果计入贡献（填入了 $1$，且 $M$ 的这一位也是 $1$，因为是按位或），就加上 `dfs2` 的结果。

就是上文说的。

### 总结

几乎是数位 DP 板子题，难度个人感觉不大，

但是赛时写了一半晕了，没写 `dfs2` 的部分，导致假了。
