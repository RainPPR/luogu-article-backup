---
title: 题解：P10321 奉献（Dedication）
date: 1712327241
description: 首先，我们发现我们要填充一个三角形式的区域。 容易发现，如果一个点的坐标 xy 可以写为 lambda x0lambda y0 的形式， 其中 x0perp y0，lambdaneq1。 也就是 la
author: 371511
---

首先，我们发现我们要填充一个三角形式的区域。

容易发现，如果一个点的坐标 $(x,y)$ 可以写为 $(\lambda x_0,\lambda y_0)$ 的形式，

其中 $x_0\perp y_0$，$\lambda\neq1$。

也就是 $\lambda=\gcd(x,y)$，那么这个点一定被 $(x_0,y_0)$ 计算过了。

也就是如果 $\gcd(x,y)\neq1$，我们可以在 $(x_0,y_0)$ 的位置去计算它的贡献。

因此我们可以最简单的枚举每一个点，然后判断这个点是否需要单独计算。

对于需要单独计算的点，我们首先加上这个点去计算除法的消耗 $d_a\log_2d_a$。

然后考虑这个点去处理其他的点的消耗，即计算 $k$ 倍的贡献，

也就是 $n$ 以内的所有 $a$ 的倍数都要被处理，比如我们手模一组：

- 当 $n=6$，$a=3$，$b=2$ 时：
- 需要计入的贡献有：
- $d_a\log_2d_a=3\log_23$；
- $k=1$（$3,2$），$k=2$（$6,4$）。

易发现我们就是对 $1\sim\lfloor n/a\rfloor$ 的 $d_k$​​ 求和，可以前缀和处理。

不过我们要理解一下为什么是 $n/a$ 而不是 $n/b$。

额其实也不用理解，因为 $a\ge b$（回顾一下题面，别忘了要求啥）。

然后我们推式子吧！可以很容易的得出答案的式子：
$$
\mathit{Ans}=\sum_{a=1}^n\sum_{b=1}^a[\gcd(a,b)=1](d_a\log_2d_a+\sum_{k=1}^{\lfloor n/a\rfloor}d_k)
$$
注意到对 $d_k$ 求和很烦人，因此记 $s_k$ 表示从 $1$ 对 $d$ 求和：
$$
\mathit{Ans}=\sum_{a=1}^n\sum_{b=1}^a[\gcd(a,b)=1](d_a\log_2d_a+s_{\lfloor n/a\rfloor})
$$
注意到后面的式子与 $b$​ 无关，因此：
$$
\mathit{Ans}=\sum_{a=1}^n(d_a\log_2d_a+s_{\lfloor n/a\rfloor})\sum_{b=1}^a[\gcd(a,b)=1]
$$
注意到后面的东西就是欧拉函数 $\varphi$，因此：
$$
\mathit{Ans}=\sum_{a=1}^n\varphi(a)\cdot(d_a\log_2d_a+s_{\lfloor n/a\rfloor})
$$
然后预处理 $d_k$、$s_k$、$\varphi(a)$ 即可，代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n;

vector<int> d, s;
vector<double> q;

vector<int> primes, isprime;
vector<int> phi;

void init() {
    d.resize(n + 1), s.resize(n + 1), q.resize(n + 1);
    for (int i = 1; i <= n; ++i) d[i] = d[i / 10] + 1, s[i] = s[i - 1] + d[i], q[i] = d[i] * log2(d[i]);
}

void euler() {
    primes.clear(), isprime.resize(n + 1, 1), phi.resize(n + 1);
    phi[1] = 1; for (int i = 2; i <= n; ++i) {
        if (isprime[i]) primes.push_back(i), phi[i] = i - 1;
        for (int j : primes) {
            if (j * i > n) break; isprime[j * i] = 0;
            if (i % j) phi[j * i] = phi[i] * (j - 1);
            else { phi[j * i] = phi[i] * j; break; }
        }
    }
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin >> n; init(); euler(); double res = 0;
    for (int a = 1; a <= n; ++a) res += phi[a] * (q[a] + s[int(n / a)]);
    printf("%.10lf", res); return 0;
}
```

本人是在考场上没有把式子写下来（其实是太菜不会），没有发现 $\varphi$ 这么好（简单）的东西。
