---
title: 题解：CF1508A Binary Literature
date: 1732713564
description: b'5qC55o2u6bi95bei5Y6f55CG77yM5LiA5Liq6ZW/5bqm5Li6ICROJCDnmoQgJDAvMSQg5Liy5LiA5a6a5pyJ5LiA5Liq5a2X56ym5Ye6546w5qyh5pWwICRcZ2VcbGZsb29yIE4vMlxyZmxvb3Ik44CCCgrlm6DmraTvvIzlnKjkuInkuKrlrZfnrKbkuLLkuK3kuIDlrprmnInkuIDlr7nlrZfnrKbkuLLvvIzku5bku6zlh7rnjrDmrKHmlbDlpJrkuo7kuIDljYrnmoTlrZfnrKbnm7jlkIzjgIIKCuatpOaXtu+8jOS4gOWumuWPr+S7pemAmui/h+Wwhui/meS4qumDveWkmuS6juS4gOWNiuWtl+espuS9nOS4uuWPguiAg++8jOWFtuS7luWtlw=='
author: 371511
---

根据鸽巢原理，一个长度为 $N$ 的 $0/1$ 串一定有一个字符出现次数 $\ge\lfloor N/2\rfloor$。

因此，在三个字符串中一定有一对字符串，他们出现次数多于一半的字符相同。

此时，一定可以通过将这个都多于一半字符作为参考，其他字符顺次穿插。

更直观的，我们将两个字符串这个相同的字符从前到后依次对应，其他元素插入即可。

```plain
    0 1 1 0 0 0 1 0 0
    0 1 0 1 0 1 0 1 0
-------------------------------
=>  0 1 1 0   0   0 1 0 0
    |     |   |   |   |
    0 1   0 1 0 1 0 1 0
-------------------------------
=>  0 1 1 1 0 1 0 1 0 1 1 0 0 0
```

注意到这样构造出来的字符串长度一定 $\le3N$，符合要求。

```
vector<int> get_pos(const string &a, char split) {
	vector<int> pos;
	for (size_t i = 0; i < a.size(); ++i)
		if (a[i] == split)
			pos.push_back(i);
	return pos;
}

string merge(const string &a, const string &b, char split) {
	auto s = get_pos(a, split);
	auto t = get_pos(b, split);
	if (s.empty() || t.empty())
		return a + b;
	string res;
	size_t x = min(s.size(), t.size());
	int ls = 0, ts = 0;
	for (size_t i = 0; i < x; ++i) {
		res += a.substr(ls, s[i] - ls);
		res += b.substr(ts, t[i] - ts);
		ls = s[i] + 1;
		ts = t[i] + 1;
		res.push_back(split);
	}
	res += a.substr(ls);
	res += b.substr(ts);
	return res;
}

string solve() {
	string a, b, c;
	read(a, b, c);
	string ab0 = merge(a, b, '0');
	string ab1 = merge(a, b, '1');
	string ac0 = merge(a, c, '0');
	string ac1 = merge(a, c, '1');
	string bc0 = merge(b, c, '0');
	string bc1 = merge(b, c, '1');
	return min(
		{ ab0, ab1, ac0, ac1, bc0, bc1 },
		[] (const string &a, const string &b) {
			return a.size() < b.size();
		}
	);
}
```

实现上，我们不妨先求出每一个字符的出现位置，按照这个位置一次插入即可。
