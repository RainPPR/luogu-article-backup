---
title: 题解：AT_abc354_d [ABC354D] AtCoder Wallpaper
date: 1716117813
description: 容易发现（观察图像），


xgets x4
ygets y2


对答案没有任何影响，因此考虑将最复杂的负数坐标全部转化，

即给定的两个点的坐标，全部加上 1094。

这里这么做保证了所有坐标为正数，因此可以直接差
author: 371511
---

容易发现（~~观察图像~~），

$$
x\gets x+4\\
y\gets y+2
$$

对答案没有任何影响，因此考虑将最复杂的负数坐标全部转化，

即给定的两个点的坐标，全部加上 $10^9+4$。

这里这么做保证了所有坐标为正数，因此可以直接差分，

考虑二维差分，我们计算 $(0,0)(x,y)$ 的答案，

那么对于 $(a,b)(c,d)$ 的答案，我们用 $A$ 表示，

$$
A(a,b,c,d)=A(c,d)-A(a,d)-A(c,b)+A(a,b)
$$

然后考虑这个后面的函数如何实现，

重复一遍需求：计算 $(0,0)(x,y)$ 的答案。

容易发现，一个 $4\times2$ 的矩阵是重复的。

而且对于这个重复的部分，其上下两个 $4\times1$ 的矩阵是等价的。

而对于不属于这个部分的地方，才会有上下两个 $4\times1$ 的矩阵是不同的。

对于下面的情况，容易发现其上下两个 $x\times2(0<x<4)$ 又是等价的。

据此，可以直接 $\mathcal O(1)$ 的计算。

因为我们多计算了很多的区域，答案可能很大，注意开 `longlong`。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

using ll = long long;

ll solev(ll a, ll b) {
    ll xgroup = a / 4;
    ll xleft = a % 4;
    ll ygroup = b / 2;
    ll yleft = b % 2;
    ll ans = xgroup * b * 4;
    if (xleft >= 1) {
        ans += ygroup * 3;
        ans += yleft * 2;
    }
    if (xleft >= 2) {
        ans += ygroup * 3;
        ans += yleft;
    }
    if (xleft >= 3) {
        ans += ygroup;
    }
    if (xleft >= 4) {
        ans += ygroup;
        ans += yleft;
    }
    return ans;
}

constexpr int add = 1e9 + 4;

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    ll a, b, c, d; cin >> a >> b >> c >> d;
    a += add, b += add, c += add, d += add;
    cout << solev(c, d) - solev(a, d) - solev(c, b) + solev(a, b) << endl;
    return 0;
}
```
