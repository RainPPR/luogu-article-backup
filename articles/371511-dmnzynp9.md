---
title: P5303 [GXOI/GZOI2019] 逼死强迫症 题解
date: 1710079716
description: 首先先不考虑 1times1 的方砖。

设 gn 表示填完 2times n 的方格的方案数。注意到只可能有下面两种形态：

httpscdnluogucomcnuploadimagehostingzhv3m
author: 371511
---

首先先不考虑 $1\times1$ 的方砖。

设 $g_n$ 表示填完 $2\times n$ 的方格的方案数。注意到只可能有下面两种形态：

![](https://cdn.luogu.com.cn/upload/image_hosting/zhv3mpvi.png)

因此有 $g_n=g_{n-1}+g_{n-2}$。同时我们也可以得出 $\sum_{i=1}^ng_i=g_{n+2}-1$。

然后去考虑 $1\times1$ 的方砖。

设 $f_n$ 为按照题意填完 $2\times n$ 的方格的方案数。显然情况分为下面四种：

![](https://cdn.luogu.com.cn/upload/image_hosting/927ks36y.png)

注意到下面两种其实是等价的，可以代数乘二。

而这两种，两个 $1\times1$ 的方砖是不能相邻的，其最小间隔为 $3$，

因此：$f_n=f_{n-1}+f_{n-2}+2\sum_{j=0}^{n-3}g_i=f_{n-1}+f_{n-2}+2g_{n-1}-2$。

于是，考虑矩阵乘法优化线性递推：

$$
\begin{bmatrix}
1&1&2&0&1\\
1&0&0&0&0\\
0&0&1&1&0\\
0&0&1&0&0\\
0&0&0&0&1
\end{bmatrix}\begin{bmatrix}
f_{n-1}\\f_{n-2}\\g_{n-1}\\g_{n-2}\\-2
\end{bmatrix}=\begin{bmatrix}
f_n\\f_{n-1}\\g_n\\g_{n-1}\\-2
\end{bmatrix}
$$

然后就很简单了。

```cpp
#include <bits/stdc++.h>

using namespace std;

constexpr int m = 1e9 + 7;

struct emm {
	int n;
	vector<vector<int>> a;
	emm() = default;
	emm(int n): n(n) { a.resize(n, vector<int>(n)); }
	friend emm operator *(const emm &a, const emm &b) {
		int n = a.n; emm r(n);
		for (int i = 0; i < n; ++i)
		for (int k = 0; k < n; ++k)
		for (int j = 0; j < n; ++j)
		r.a[i][j] = (r.a[i][j] + 1ll * a.a[i][k] * b.a[k][j] % m) % m;
		return r;
	}
};

emm qpow(emm a, int k) {
	emm r = a; --k;
	for (; k; k >>= 1) {
		if (k & 1) r = r * a;
		a = a * a;
	} return r;
}

int solve(int n) {
	if (n <= 1) return 0;
	if (n == 2) return 0;
	emm a(5);
	a.a[0][0] = 1, a.a[0][1] = 1, a.a[0][2] = 2, a.a[0][3] = 0, a.a[0][4] = 1;
	a.a[1][0] = 1, a.a[1][1] = 0, a.a[1][2] = 0, a.a[1][3] = 0, a.a[1][4] = 0;
	a.a[2][0] = 0, a.a[2][1] = 0, a.a[2][2] = 1, a.a[2][3] = 1, a.a[2][4] = 0;
	a.a[3][0] = 0, a.a[3][1] = 0, a.a[3][2] = 1, a.a[3][3] = 0, a.a[3][4] = 0;
	a.a[4][0] = 0, a.a[4][1] = 0, a.a[4][2] = 0, a.a[4][3] = 0, a.a[4][4] = 1;
	a = qpow(a, n - 1);
	return ((a.a[0][2] + a.a[0][3]) % m - 2 * a.a[0][4] % m + m) % m;
}

signed main() {
	int t, n; cin >> t;
	while (t--) cout << solve((cin >> n, n)) << endl;
	return 0;
}
```
