---
title: 算法笔记 lyd
date: 1716352393
description:  【】数值相关

 快速幂

cpp
ll qpowll a ll b ll p 
	ll r  1  p a  p
	for  b b  1 
		if b  1 r  r  a  p

author: 371511
---

## 【】数值相关

### 快速幂

```cpp
ll qpow(ll a, ll b, ll p) {
	ll r = 1 % p; a %= p;
	for (; b; b >>= 1) {
		if (b & 1) r = r * a % p;
		a = a * a % p;
	} return r;
}
```

### 龟速乘

```cpp
ll sadd(ll a, ll b, ll p) {
	ll r = 0; a %= p;
	for (; b; b >>= 1) {
		if (b & 1) r = (r + a) % p;
		a = (a + a) % p;
	} return r;
}
```

### 汉诺塔问题

有递推关系，

$$
F_1=1\\
F_n=2F_n+1
$$

下式两边加一，可得封闭性：

$$
F_n=2^n-1
$$

### 因数之和

考虑，

$$
\begin{aligned}
S=&
\;(1+p_1+p_1^2+\dots+p_1^{c_1})\\
&\;(1+p_2+p_2^2+\dots+p_2^{c_2})\\
&\;\dots\\
&\;(1+p_k+p_k^2+\dots+p_k^{c_k})\\
\end{aligned}
$$

每一行都是等比数列。

$$
S_n=a_1\cdot{q^{n+1}-1\over q-1}
$$

对于分式取模，若分母有逆元，处理。

若没有逆元，则有，

$$
q\equiv1\pmod m
$$

则等比数列，

$$
S_n=(n+1)a_1
$$


## 【】图论相关

### 最短 Hamilton 路径

状态压缩，设 $F(u,e)$ 表示到 $u$ 经过 $e$ 集合的点时的最短长度。

```cpp
int dfs(int u, int e) {
	if (u == 1 && e == 1) return 0;
	if (!(e & (1 << u - 1))) return 0x3f3f3f3f;
	if (vis[u][e]) return dp[u][e];
	for (int i = 1; i <= n; ++i) {
		if (i == u || !(e & (1 << i - 1))) continue;
		dp[u][e] = min(dp[u][e], dis[i][u] + dfs(i, e ^ (1 << u - 1)));
	} return vis[u][e] = 1, dp[u][e];
}
```

## 【】矩阵相关

### 开关闭合问题

每按下一个位置的开关，其上下左右都切换。

朴素算法，$\mathcal O(2^{n^2})$。

优化算法，$\mathcal O(2^nn^2)$。

考虑枚举第一行每个位置是否切换，然后对于下面的，

如果上面的不是目标状态就需要切换，来满足上面的需求。

最后枚举最下面一行的，如果结果符合预期，则是一种合法答案。

还可以用高斯消元解异或线性方程组来求解这个问题。

```cpp
int solev() {
	int ans = 7;
	for (int i = 1; i <= 5; ++i)
		for (int j = 1; j <= 5; ++j)
			a[i][j] = gc() - '0';
	for (int e = 0; e < (1 << 5); ++e) {
		for (int i = 1; i <= 5; ++i)
			for (int j = 1; j <= 5; ++j)
				b[i][j] = a[i][j];
		int cnt = 0;
		for (int i = 1; i <= 5; ++i)
			if (e & (1 << i - 1)) ps(1, i), ++cnt;
		for (int i = 2; i <= 5; ++i)
			for (int j = 1; j <= 5; ++j)
				if (!b[i - 1][j]) ps(i, j), ++cnt;
		int ok = 1;
		for (int i = 1; i <= 5; ++i)
			if (!b[5][i]) ok = 0;
		if (ok) ans = min(ans, cnt);
	} return ans > 6 ? -1 : ans;
}
```

### 奇数码问题

$n\times n$ 的矩阵，$n$ 为奇数，一个空位，空位交换。

性质：交换元素，从上到下、从左到右逆序数奇偶性不变，

且若逆序数奇偶性不变则一定可以达到。

## 【】序列相关

### 前缀和、差分数组的应用

对于序列区间加，可以转化为差分数组的单点修改。

一些特殊性质可以转化为差分数组中的性质，比如树状数组区间加。

### 二维前缀和、差分

```cpp
int a[N][N];

int to(int x) {
    if (x < 0) return 0;
    if (x >= N) return N - 1;
    return x;
}

signed main() {
	int n, r, w, ans = 0; cin >> n >> r; vector<pii> s(n);
	for (auto &[x, y] : s) cin >> x >> y >> w, ++x, ++y, a[x][y] += w;
	for (int i = 1; i < N; ++i) for (int j = 1; j < N; ++j)
		a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];
	for (int i = 1; i < N; ++i) for (int j = 1; j < N; ++j)
		ans = max(ans, a[i][j] - a[to(i - r)][j] - a[i][to(j - r)] + a[to(i - r)][to(j - r)]);
	cout << ans << endl;
	return 0;
}
```

### 序列平均数

判断序列是否存在平均值不小于 $x$ 的数，存在 $
\mathcal O(n)$ 的做法。

可以用于将一些操作，转化为二分，达到优化的目的。

具体的，我们把原序列每个数 $x_i\gets x_i-x$，然后区间和不小于零的即所求区间。

考虑前缀和，最大和的区间一定是本身减去左面最小的，同步记录。

```cpp
bool check(double avg) {
	for (int i = 1; i <= n; ++i) b[i] = b[i - 1] + a[i] - avg;
	double lt = 0;
	for (int i = 0, j = f; j <= n; ++i, ++j) {
		lt = min(lt, b[i]);
		if (b[j] - lt >= 0) return true;
	} return false;
}
```

### 序列中位数

动态维护，每次插入只会影响一个数，因此对顶堆。

不断达到左右平衡。

```cpp
int n = rr, mid = rr, a; printf("%d\n", mid);
priority_queue<int, vector<int>, less<int>>    cmin;
priority_queue<int, vector<int>, greater<int>> cmax;
for (int i = 0; i < n - 1; ++i) {
    ((a = rr) < mid) ? cmin.push(a) : cmax.push(a);
    while (cmin.size() > cmax.size()) {
        a = cmin.top(); cmin.pop();
        cmax.push(mid); mid = a;
    }
    while (cmax.size() > cmin.size()) {
        a = cmax.top(); cmax.pop();
        cmin.push(mid); mid = a;
    } if (i & 1) printf("%d\n", mid);
}
```

### 离散化

```cpp
vector<int> s;
// s.push_back(...);
sort(s.begin(), s.end());
s.erase(unique(s.begin(), s.end()), s.end());
```

### 逆序对

离散化，树状数组。可以归并但是不好写。

```cpp
#define lowbit(x) ((x) & -(x))

void add(int x) {
	for (; x <= n; x += lowbit(x)) ++e[x];
}

int qry(int x) {
	int sum = 0;
	for (; x; x -= lowbit(x)) sum += e[x];
	return sum;
}

void solev() {
	vector<int> a(n), s(n);
	for (int i = 0; i < n; ++i) cin >> a[i], s[i] = a[i], e[i + 1] = 0;
	sort(s.begin(), s.end());
	s.erase(unique(s.begin(), s.end()), s.end());
	unordered_map<int, int> to;
	for (int i = 0; i < n; ++i) to[s[i]] = i;
	for (int i = 0; i < n; ++i) a[i] = to[a[i]] + 1;
	ll cnt = 0;
	for (int i = n - 1; i >= 0; --i) cnt += qry(a[i]), add(a[i]);
	cout << cnt << endl;
}
```

## 【】贪心算法

### 货仓选址

选择一个位置，使得直线上其他点到这个点的距离之和最小。

$$
\sum|x_i-x|
$$

最小，为 $x$ 为 $x_i$ 序列中位数，或者中间两个数中间任何一个位置。

### 均分纸牌

将纸牌相邻移动，使得均分，最小移动个数。

最后一定是每个人平均数个，因此一个前缀和比这个数差多少就需要移过去多少。

### 环形均分纸牌

上一题的条件下，围成一个环，可以最左最右交换。

一定存在一条边不通过流量，枚举，求解。

$$
\sum|s_i-s_k|
$$

即货仓选址问题，选 $s_k$ 为中位数，计算即可。

### 行列环形均分纸牌

行列独立，因为可以直接推着走，等价。

```cpp
int n, m, t;
int a[N], b[N];
int s[N];

ll solev_row() {
	int avg = t / n;
	for (int i = 1; i <= n; ++i) s[i] = s[i - 1] + a[i] - avg;
	sort(s + 1, s + 1 + n);
	ll ans = 0; int mid = s[(n >> 1) + 1];
	for (int i = 1; i <= n; ++i) ans += abs(s[i] - mid);
	return ans;
}

ll solev_col() {
	int avg = t / m;
	for (int i = 1; i <= m; ++i) s[i] = s[i - 1] + b[i] - avg;
	sort(s + 1, s + 1 + m);
	ll ans = 0; int mid = s[(m >> 1) + 1];
	for (int i = 1; i <= m; ++i) ans += abs(s[i] - mid);
	return ans;
}
```

### 区间分组

将区间分为若干组，各组互不相交，最小化组数。

按照左端点升序排序，每个区间依次加入。

如果可以加入，那么加入到右端点最远的一个。

否则自己新开一组。

```cpp
struct emm {
	int id, l, r;
	friend bool operator <(const emm &a, const emm &b) {
		return a.l < b.l;
	}
};

int n; cin >> n; vector<emm> a(n);
for (int i = 0; i < n; ++i) cin >> a[i].l >> a[i].r, a[i].id = i + 1;
sort(a.begin(), a.end());
vector<int> ans(n + 1); int cnt = 0;
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> heap;
for (auto [id, l, r] : a) {
	if (heap.empty() || heap.top().first >= l) ans[id] = ++cnt, heap.push({r, ans[id]});
	else ans[id] = heap.top().second, heap.pop(), heap.push({r, ans[id]});
}
cout << cnt << endl;
for (int i = 1; i <= n; ++i) cout << ans[i] << endl;
```

### 区间选点

选出若干个点，使得所有给出区间都至少被一个点覆盖。

按照区间右端点排序，如果当前最靠右的点已经覆盖这个区间，跳过。

否则在这个区间的右端点，放置一个点。

```cpp

struct emm {
	double l, r;
	friend bool operator <(const emm &a, const emm &b) {
		return a.r < b.r;
	}
};

sort(a.begin(), a.end());
int ans = 0; double ed = -2e9;
for (auto [l, r] : a) if (l > ed) ++ans, ed = r;
cout << ans << endl;
```

## 【】数据结构

### 单调栈

若栈顶失效，弹出。

加入当前的元素。

可用于求解左边比它大的最小的元素，等。

### 单调队列

若队首失效，弹出。

删除队尾无效元素，加入当前元素。

可用于转移 $\min,\max$ 在一定长度范围内的线性动态规划。

### 哈希表

建议使用 unordered_set/map。

需要手写结构体等于的判断、哈希值函数，形如，

```cpp
struct emm {
    array<int, 6> s;
    friend bool operator ==(const emm &a, const emm &b) {
        if (a.s == b.s) return 1;
        reverse(a.s.begin(), a.s.end());
        if (a.s == b.s) return 1;
        return 0;
	}
};

struct my_hash {
    ll operator ()(const emm a) const {
        ll r = 0;
        for (int i : a.s) r = (r + i) % P;
        return r;
    }
};

unordered_set<emm, my_hash> app;
```

注意 hash 后面的 const 在 Win 环境下不写可以，但是 Linux 会 CE。

### 字符串哈希

```cpp
using ull = long long;

constexpr ull p1 = 131, m1 = 1e9 + 7;
constexpr ull p2 = 13331, m2 = 1e9 + 9;

constexpr int N = 1e6 + 10;

ull fr1[N], fr2[N];

int idx(char c) {
	return c - 'a';
}

void init() {
	fr1[0] = 1, fr2[0] = 1;
	for (int i = 1; i < N; ++i)
		fr1[i] = fr1[i - 1] * p1 % m1,
		fr2[i] = fr2[i - 1] * p2 % m2;
}

class strhash {

private:

	vector<ull> h1, h2;

public:

	strhash(string s) {
		h1.resize(s.size() + 1);
		h2.resize(s.size() + 1);
		h1[0] = 0, h2[0] = 0;
		for (int i = 1; i <= (int)s.size(); ++i)
			h1[i] = (h1[i - 1] * p1 % m1 + idx(s[i - 1])) % m1,
			h2[i] = (h2[i - 1] * p2 % m2 + idx(s[i - 1])) % m2;
	}

	ull sub_hash1(int l, int r) {
		return (h1[r] - h1[l - 1] * fr1[r - l + 1] % m1 + m1) % m1;
	}

	ull sub_hash2(int l, int r) {
		return (h2[r] - h2[l - 1] * fr2[r - l + 1] % m2 + m2) % m2;
	}

};
```

如果不需要字串哈希，可以手写哈希函数，用 umap。
