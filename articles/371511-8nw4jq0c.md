---
title: 题解：AT_abc354_c [ABC354C] AtCoder Magics
date: 1716117168
description: 对于题目给出的性质，我们肯定是想要去证明的， 但是容易发现求解本题的过程本身就是一个构造性的证明。 注意到，牌力 Ai 最大的一张牌，永远不会被 AxAi 选中而丢弃。 根据这个可以得出非常重要的一个性质，牌力最大的牌，一定会保留。
author: 371511
---

对于题目给出的性质，我们肯定是想要去证明的，

但是容易发现求解本题的过程本身就是一个构造性的证明。

注意到，牌力 $A_i$ 最大的一张牌，永远不会被 $A_x>A_i$ 选中而丢弃。

根据这个可以得出非常重要的一个性质，牌力最大的牌，一定会保留。

考虑到根据题目描述，最终得到的是怎样一个序列，

容易发现，我们将 $A_i$ 降序排列，则这个序列的 $C_i$ 应当也是递减的。

因为题目规定了 $A_i,C_i$ 两两不同，因此不需要考虑 $A_i$ 相同时的结果。

根据上述两条性质，我们可以给出确定性的构造：

从牌力 $A_i$ 最大的开始，依次 $A_i$ 递减，只有 $C_i$ 递减的才会保留。

容易发现，目前得到的这个序列是确定且唯一的。

考虑继续证明，在 $A_i$ 递减且 $C_i$ 也递减的序列中，每一张牌都会被保留。

其实只要读懂题了这个都很容易证明，这个只能算观察了，

因为在 $A_j>A_i$ 的中，所有的 $C_j>C_i$ 成立，因此 $i$ 一定不会被丢弃。

证毕，我们梳理一遍思路，

+ 将所有牌按照 $A_i$ 递减排序。
+ 考虑保留最大的 $A_i$ 的牌，然后枚举后面的每一张牌，
+ 如果加入这张牌，可以保持 $C_i$ 递减的性质，那么加入，
+ 否则，丢弃。

代码实现也不难，

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

template<typename tp>
istream& operator >>(istream &in, vector<tp> &a) {
    for (tp &t : a) in >> t;
    return in;
}

template<typename tp>
ostream& operator <<(ostream &out, vector<tp> &a) {
    for (auto i : a) out << i << " ";
    return out;
}

constexpr int N = 2e5 + 10;

int a[N], c[N];

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n; cin >> n; vector<int> id(n);
    for (int i = 0; i < n; ++i) cin >> a[i] >> c[i], id[i] = i;
    sort(id.begin(), id.end(), [] (int i, int j) { return a[i] > a[j]; });
    int mx = 2e9; vector<int> ans;
    for (int i : id) if (c[i] < mx) mx = c[i], ans.push_back(i + 1);
    sort(ans.begin(), ans.end());
    cout << ans.size() << endl << ans << endl;
    return 0;
}
```
