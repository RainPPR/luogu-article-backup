---
title: 题解：AT_abc356_e [ABC356E] Max/Min
date: 1717337780
description:  题目描述 对于长度为 N 的序列，  AA1A2dotsAN  求出，  sumi1N1sumji1NleftlfloormaxAiAjovermin
author: 371511
---

### 题目描述

对于长度为 $N$ 的序列，
$$
A=(A_1,A_2,\dots,A_N)
$$
求出，
$$
\sum_{i=1}^{N-1}\sum_{j=i+1}^N\left\lfloor{\max\{A_i,A_j\}\over\min\{A_i,A_j\}}\right\rfloor
$$

### 题解

注意到 $\max,\min$ 函数不好处理，我们考虑观察这个求和的性质。

注意到，式子
$$
\left\lfloor{\max\{A_i,A_j\}\over\min\{A_i,A_j\}}\right\rfloor
$$
是计算对每一对 $(i,j)$ 且 $i<j$ 的贡献，

那么，当我们把序列任意 $A_i,A_j$ 交换，不会影响最终的结果。

因此，考虑把序列 $A$ 先升序排序，那么，
$$
(i<j)\Rightarrow(A_i\le A_j)
$$
因此，
$$
\left\lfloor{\max\{A_i,A_j\}\over\min\{A_i,A_j\}}\right\rfloor=\left\lfloor{A_j\over A_i}\right\rfloor
$$
式子已经化简为，
$$
\sum_{i=1}^{N-1}\sum_{j=i+1}^N\left\lfloor{A_j\over A_i}\right\rfloor
$$
这个东西很类似于数论分块，容易发现，

我们考虑对每一个 $A_i$ 去计算 $A_j$ 所能造成的贡献，

对于每一个 $A_i$，我们暴力枚举每一个后面下取整式子可能的结果 $k$，

这个结果 $k$ 所能对应的 $A_j$ 应当符合，
$$
A_j\in\left[kA_i,(k+1)A_i-1\right)
$$
于是，我们枚举 $k$，然后计入这个区间内的数目的贡献。

为了实现方便，我们直接枚举这个开头 $kA_i$，

那么，这个区间的右端点为 $kA_i+A_i-1$，然后乘上贡献
$$
\left\lfloor{kA_i\over A_i}\right\rfloor=k
$$
即可。

容易证明，时间复杂度为：$\mathcal O(M\log M)$​。

证明：

对于每一个枚举的 $A_i$，我们都要遍历 $kA_i$ 直到最大值，因此
$$
\begin{aligned}
\left\lfloor{M\over A_1}\right\rfloor+\left\lfloor{M\over A_2}\right\rfloor+\dots+\left\lfloor{M\over A_N}\right\rfloor&\le\left\lfloor{M\over 1}\right\rfloor+\left\lfloor{M\over 2}\right\rfloor+\dots+\left\lfloor{M\over M}\right\rfloor\\
&\le{M\over 1}+{M\over 2}+\dots+{M\over M}\\
&=M\left({1\over 1}+{1\over 2}+\dots+{1\over M}\right)\\
&\le M\ln M
\end{aligned}
$$
这里用到了调和级数，复杂度整体就是 $\mathcal O(M\log M)$ 的。

PS：这里假设 $A_i$ 两两不等，因为我们可以直接统计次数来计算。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

using ll = long long;

constexpr int N = 1e6 + 10;

int n, cnt[N], sum[N];

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    cin >> n; for (int i = 0, x; i < n; ++i) cin >> x, ++cnt[x];
    for (int i = 1; i <= 1e6; ++i) sum[i + 1] = sum[i] + cnt[i];
    ll ans = 0;
    for (int a = 1; a <= 1e6; ++a) {
        ll c = cnt[a], res = 0;
        if (c == 0) continue;
        for (int l = a; l <= 1e6; l += a) {
            int r = min(l + a, (int)1e6 + 1);
            res += 1ll * (sum[r] - sum[l]) * (l / a);
        }
        ans += c * res - c * (c + 1) / 2;
    }
    cout << ans << endl;
    return 0;
}
```
