---
title: 题解：P10449 费解的开关
date: 1716514235
description: 注意到当进行一个操作的时候，只会对其上方一行的一个值造成影响。

因此考虑枚举第一行每个位置是否操作，然后顺下去。

即下面的每一行都去判断这个需不需要操作，以保证上一行全部打开。

对于最后一行，我们进行操作完后，没有去保证它的了，因此这一行决定了一个枚
author: 371511
---

注意到当进行一个操作的时候，只会对其上方一行的一个值造成影响。

因此考虑枚举第一行每个位置是否操作，然后顺下去。

即下面的每一行都去判断这个需不需要操作，以保证上一行全部打开。

对于最后一行，我们进行操作完后，没有去保证它的了，因此这一行决定了一个枚举是否可行。

具体细节看代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

char gc() {
	char c = getchar();
	while (!isdigit(c)) c = getchar();
	return c;
}

int a[10][10], b[10][10];

void ps(int i, int j) {
	b[i][j] ^= 1;
	b[i - 1][j] ^= 1, b[i + 1][j] ^= 1;
	b[i][j - 1] ^= 1, b[i][j + 1] ^= 1;
}

int solev() {
	int ans = 7;
	for (int i = 1; i <= 5; ++i)
		for (int j = 1; j <= 5; ++j)
			a[i][j] = gc() - '0';
	for (int e = 0; e < (1 << 5); ++e) {
		for (int i = 1; i <= 5; ++i)
			for (int j = 1; j <= 5; ++j)
				b[i][j] = a[i][j];
		int cnt = 0;
		for (int i = 1; i <= 5; ++i)
			if (e & (1 << i - 1)) ps(1, i), ++cnt;
		for (int i = 2; i <= 5; ++i)
			for (int j = 1; j <= 5; ++j)
				if (!b[i - 1][j]) ps(i, j), ++cnt;
		int ok = 1;
		for (int i = 1; i <= 5; ++i)
			if (!b[5][i]) ok = 0;
		if (ok) ans = min(ans, cnt);
	} return ans > 6 ? -1 : ans;
}

signed main() {
	// ios::sync_with_stdio(false);
	// cin.tie(nullptr), cout.tie(nullptr);
	int T; cin >> T;
	while (T--) cout << solev() << endl;
	return 0;
}
```

时间复杂度：$\mathcal O(T2^nn^2)$。

在这道题里面，$T$ 就是输入的 $n$（数据组数），$n$ 就是方块大小 $5$ 哦。
