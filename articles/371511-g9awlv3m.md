---
title: 题解：P11217 【MX-S4-T1】「yyOI R2」youyou 的垃圾桶
date: 1729428467
description: 本题解时间复杂度为 mathcal Oqlog2n 的卡常做法，优点是思维难度小、实现较容易。  设进行了 k 轮完整的，我们假设最后恰好的一轮不算。设 Rsumi1nai 表示一轮、不计系数的总伤害，根据等
author: 371511
---

本题解时间复杂度为 $\mathcal O(q\log^2n)$ 的卡常做法，优点是思维难度小、实现较容易。

---

设进行了 $k$ 轮完整的，我们假设最后恰好的一轮不算。设 $R=\sum_{i=1}^na_i$ 表示一轮、不计系数的总伤害，根据等比数列求和，我们知道要求 $k$ 恰好满足：

$$
\begin{aligned}
(2^{k+1}-1)R&\ge W\\
2^{k+1}-1&\ge\dfrac WR=\lambda\\
2^{k+1}&\ge\lambda+1\\
k+1&\ge\log_2(\lambda+1)\\
k&=\lceil\log_2(\lambda+1)-1\rceil
\end{aligned}
$$

那么，在经过 $k$ 轮之后，记现在的血量为 $T=W-(2^k-1)R$，记 $S$ 为 $a_i$ 的前缀和，我们需要找到第一个 $p$ 满足：

$$
\begin{aligned}
2^kS(p)&\ge T\\
S_p&\ge\dfrac{T}{2^k}\\
S_p&\ge\left\lceil\dfrac{T}{2^k}\right\rceil
\end{aligned}
$$

可以二分查找、使用数据结构维护，那么答案就是 $nk+p-1$。

---

代码实现上，为了实现区间加、区间查询，我们可以使用线段树，但是会被卡常。因此我们使用两个树状数组维护，具体的，假设我们维护了一个差分数组，我们要查询：

$$
\begin{aligned}
S(x)&=\sum_{i=1}^xa_i\\
a_x&=\sum_{i=1}^xd_i
\end{aligned}
$$

那么，

$$
S(x)=\sum_{i=1}^x\sum_{j=1}^id_j=\sum_{i=1}^xd_i(x-i+1)
$$

![](https://cdn.luogu.com.cn/upload/image_hosting/t6flhcrh.png)

如上图所示，整理得：

$$
S(x)=(x+1)\sum_{i=1}^xd_i-\sum_{i=1}^xi\cdot d_i
$$

使用树状数组维护前缀和、乘下标的前缀和即可。区间加法使用差分维护即可，这是经典技巧。

---

代码（包含了赛时被卡 TLE 的线段树代码）：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl "\n"

using ll = long long;

#define int ll

constexpr int N = 2e5 + 10;

int n, q, w;

int b[N];

namespace seg {
	// #define ls(k) ((k) << 1)
	// #define rs(k) ((k) << 1 | 1)
	// #define avg(l, r) (((l) + (r)) >> 1)

	// struct node {
	// 	int l, r;
	// 	int v, tag;
	// } a[N << 2];

	// void action(int k, int v) {
	// 	a[k].tag += v;
	// 	a[k].v += (a[k].r - a[k].l + 1) * v;
	// }

	// void push_down(int k) {
	// 	if (a[k].tag == 0)
	// 		return;
	// 	action(ls(k), a[k].tag);
	// 	action(rs(k), a[k].tag);
	// 	a[k].tag = 0;
	// }

	// void push_up(int k) {
	// 	a[k].v = a[ls(k)].v + a[rs(k)].v;
	// }

	class fenwick {
		private:

			#define lowbit(x) ((x) & -(x))

			int m;

			int s[N], a[N];

		public:

			void resize(int n) {
				m = n;
				memset(s, 0, sizeof(int) * (n + 1));
				memset(a, 0, sizeof(int) * (n + 1));
			}

			void modify(int x, int v) {
				for (; x <= m; x += lowbit(x))
					s[x] += v;
			}

			int query(int x) {int r = 0;
				for (; x; x -= lowbit(x))
					r += s[x];
				return r;
			}
	} a, ai;

	void build(int k, int l, int r) {
		a.resize(r - l + 1);
		ai.resize(r - l + 1);
		for (int i = l; i <= r; ++i) {
			a.modify(i, b[i] - b[i - 1]);
			ai.modify(i, i * (b[i] - b[i - 1]));
		}
		// a[k] = node{l, r, 0, 0};
		// if (l == r)
		// 	return action(k, b[l]);
		// int mid = avg(l, r);
		// build(ls(k), l, mid);
		// build(rs(k), mid + 1, r);
		// push_up(k);
	}

	void modify(int k, int p, int q, int v) {
		a.modify(p, v);
		ai.modify(p, v * p);
		if (q != n) {
			a.modify(q + 1, -v);
			ai.modify(q + 1, -v * (q + 1));
		}
		// int l = a[k].l, r = a[k].r;
		// if (l >= p && r <= q)
		// 	return action(k, v);
		// push_down(k);
		// int mid = avg(l, r);
		// if (q <= mid)
		// 	modify(ls(k), p, q, v);
		// else if (p >= mid + 1)
		// 	modify(rs(k), p, q, v);
		// else {
		// 	modify(ls(k), p, q, v);
		// 	modify(rs(k), p, q, v);
		// }
		// push_up(k);
	}

	int query(int k, int p, int q) {
		assert(p == 1);
		return (q + 1) * a.query(q) - ai.query(q);
		// int l = a[k].l, r = a[k].r;
		// if (l >= p && r <= q)
		// 	return a[k].v;
		// push_down(k);
		// int mid = avg(l, r);
		// if (q <= mid)
		// 	return query(ls(k), p, q);
		// if (p >= mid + 1)
		// 	return query(rs(k), p, q);
		// return query(ls(k), p, q) + query(rs(k), p, q);
	}
}

int query() {
	int W = w;
	int R = seg::query(1, 1, n);
	// cout << "QUERY: " << endl;
	// R 2R 4R 8R ...
	// R 3R 7R 15R
	// 2 4  8  16-1
	int k = ceil(log2(W * (long double)1.0 / R + 1) - 1);
	// cout << W << " " << R << " " << k << endl;
	int T = W - R * ((1ll << k) - 1);
	int S = (T + (1ll << k) - 1) >> k;
	// cout << "| R " << R << endl;
	// cout << "| k " << k << endl;
	// cout << "| T " << T << endl;
	// cout << "| S " << S << endl;
	int l = 1, r = n;
	int ans = 0;
	while (l <= r) {
		int mid = (l + r) >> 1;
		int res = seg::query(1, 1, mid);
		// cout << "  | " << mid << ": " << res << endl;
		if (res >= S)
			ans = mid, r = mid - 1;
		else
			l = mid + 1;
	}
	return ans + n * k - 1;
}

void Main() {
	cin >> n >> q >> w;
	for (int i = 1; i <= n; ++i)
		cin >> b[i];
	seg::build(1, 1, n);
	while (q--) {
		int l, r, d;
		cin >> l >> r >> d;
		seg::modify(1, l, r, d);
		cout << query() << endl;
	}
	return;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	return Main(), 0;
}

```
