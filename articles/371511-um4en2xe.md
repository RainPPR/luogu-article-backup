---
title: 题解：P11268 【MX-S5-T2】买东西题
date: 1731158014
description: 一眼反悔贪心。 将优惠券按照 wi 升序排序，方便一个指针遍历。 将物品按照 ai 升序排序，方便逐个加入优惠券。 注意到可以逐个物品看：  对于物品 i，将 le ai 的 wj 的优惠券 j 加入。  对
author: 371511
---

一眼反悔贪心。

将优惠券按照 $w_i$ 升序排序，方便一个指针遍历。

将物品按照 $a_i$ 升序排序，方便逐个加入优惠券。

注意到可以逐个物品看：

+ 对于物品 $i$，将 $\le a_i$ 的 $w_j$ 的优惠券 $j$ 加入。

+ 对于物品 $i$，一共有三种可能：

  + 使用折扣价。
 
  + 使用一张最优的优惠券。
 
  + 将前面一个物品的优惠券抢过来。

注意到两个物品用两个优惠券，如果交换依旧合法的话，是没必要交换的，因此可以忽略物品 $i$ 从前面抢一个优惠券，然后给前面的再安排一个优惠券的情况。

反悔贪心，不妨推一下式子，对于 $j<i$ 且 $j$ 用了优惠券 $g_j$：

+ 对于 $j$，

  + 若使用折扣价：花费 $b_j$。
 
  + 若使用优惠券：花费 $a_j-v_{g_j}$。
 
+ 对于 $i$，

  + 若使用折扣价：花费 $b_i$。
 
  + 若使用新的优惠券：花费 $a_i-v_{g_i}$。
 
  + 若抢了 $j$ 的优惠券：
 
    + 不妨将贡献后计算，即将 $j$ 的贡献于 $i$ 加入。
   
    + 花费 $a_i-v_{g_j}-[a_j-v_{g_j}]+b_j=a_i-(a_j-b_j)$。

也就是说，我们的 $i$ 抢了 $b$ 的一张优惠券，相当于 $j$ 的优惠券转化为了一个 $a_j-b_j$ 的优惠券，等待 $i$ 去使用。

容易想到，我们使用一个大根堆（`std::priority_queue`）维护这个过程。具体的，我们遍历物品 $i$、加入可以使用优惠券（同上），然后判断 $i$ 应该如何使用。如果使用折扣价，直接计算。如果使用优惠券，计算贡献后，将优惠券替换为 $a_i-b_i$ 的优惠券。

反悔贪心的正确性显然，因为我们替换的优惠券，还会再加入堆中称为新的待选优惠券，最终一定会找到对应的优惠券（看视频讲解说似乎可以通过模拟费用流解释？）。

注意到每个元素仅会被插入和删除一次，因此时间复杂度是 $\mathcal O(n\log n)$ 的。

```cpp
void Main() {
	int n, m;
	read(n, m);
	vector<pair<int, int>> a(n);
	vector<pair<int, int>> b(m);
	for (auto &[x, y] : a)
		read(x, y);
	for (auto &[x, y] : b)
		read(x, y);
	sort(a.begin(), a.end());
	sort(b.begin(), b.end());
	int i = 0;
	priority_queue<int> heap;
	long long ans = 0;
	for (auto [x, y] : a) {
		while (i < m && b[i].first <= x)
			heap.push(b[i].second), ++i;
		if (heap.empty() || x - y > heap.top())
			ans += y;
		else {
			ans += x - heap.top();
			heap.pop();
			heap.push(x - y);
		}
	}
	cout << ans << endl;
}
```

其中 `read(...)` 是快读。
