---
title: 题解：P7801 [COCI2015-2016#6] KRUMPIRKO
date: 1728439857
description: 设：  Asumi1nai   Csumi1nci  设 Fxy 表示买了 x 袋共 y 个土豆的最小花费。 我们第一个商店买 L 袋，枚举土豆数量，则答案可以表示为： 
author: 371511
---

设：

$$
A=\sum_{i=1}^na_i
$$

$$
C=\sum_{i=1}^nc_i
$$

设 $F(x,y)$ 表示买了 $x$ 袋共 $y$ 个土豆的最小花费。

我们第一个商店买 $L$ 袋，枚举土豆数量，则答案可以表示为：

$$
\min_{i=1}^{A-1}\left(\dfrac{F(l,i)}{i}\times\dfrac{C-F(l,i)}{A-i}\right)
$$

注意到 $A\le500$ 可以直接枚举，因此问题转化为求 $F(x,y)$。

注意到这个形式很背包，于是考虑加上状态。

设 $G(i,x,y)$ 表示前 $i$ 袋土豆，买 $x$ 袋 $y$ 个土豆的最小花费：

$$
G(i,x,y)=\min\{G(i-1,x,y),G(i-1,x-1,y-a_i)+c_i\}
$$

这样做时间复杂度是 $\mathcal O(N^2A)$ 可以接受。

空间上，滚动数组优化可以加上，但是没必要可以不加，下面代码加了。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl "\n"

using ll = long long;

#define int ll

constexpr int N = 110;
constexpr int V = 510;

int n, l;
int a[N], A;
int c[N], C;

int G[N][V];

void Main() {
	cin >> n >> l;
	l = min(l, n-l);
	for (int i = 1; i <= n; ++i)
		cin >> a[i], A += a[i];
	for (int i = 1; i <= n; ++i)
		cin >> c[i], C += c[i];
	memset(G, 0x3f, sizeof G);
	G[0][0] = 0;
	for (int i = 1; i <= n; ++i)
		for (int j = n; j >= 1; --j)
			for (int k = A; k >= a[i]; --k)
				G[j][k] = min(G[j][k], G[j - 1][k - a[i]] + c[i]);
	auto F = [] (int i, int j) {
		return G[i][j];
	};
	double ans = 1e18;
	for (int i = 1; i < A; ++i)
		if (F(l, i) != 0x3f3f3f3f3f3f3f3f)
			ans = min(ans, (F(l, i) * 1.0 / i) * ((C - F(l, i)) * 1.0 / (A - i)));
	printf("%.3lf\n", ans);
	return;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	return Main(), 0;
}


```
