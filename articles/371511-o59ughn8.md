---
title: 题解：P10477 Subway tree systems
date: 1718596092
description:  树的最小表示法

题目：P10477 Subway tree systemshttpswwwluogucomcnproblemP10477

题目描述：给定每一时刻是远离根（0）还是靠近根（1）。

判断两个给定的操
author: 371511
---

## 树的最小表示法

题目：[P10477 Subway tree systems](https://www.luogu.com.cn/problem/P10477).

题目描述：给定每一时刻是远离根（$0$）还是靠近根（$1$）。

判断两个给定的操作序列，所对应的两棵树是否同构。

容易发现，我们递归的处理，

+ 把每一棵子树的操作序列按照字典序排列即可。

> 考虑一些比较简单的证明：
>
> 一个操作序列一定唯一的对应着一棵树。
>
> 这是一个很重要的结论，但是也很好证明。
>
> 考虑到每一条边都只能来回经过两次，因此，
>
> 当我们进入一个点时，只能新开一个；
>
> 当我们退出一个点时，因为是树，因此只存在一个父亲。

然后考虑如何处理。

首先我们知道一个序列，一定开头是 $0$ 结尾是 $1$，

因为这两个是用于离开、回到根的。

因此，当我们删去这两个以后，其他的，

我们将 $0$ 视为 $1$，将 $1$ 视为 $-1$，那么，

如果一个区间前缀和是 $0$，那么这个区间就是一个完整的子树。

递归处理即可。

+ 具体的，递归的把序列分成若干个小块，
+ 去掉首位的 $0$ 和 $1$，然后扫描一遍。
+ 将每一小块递归处理后，加入一个数组。
+ 扫描完成后，将数组排序，拼接，即最小表示。
+ 刚开始的时候要加上首位的 $0$、$1$，因为我们的递归是从进入一棵树开始的。

```cpp
#include <bits/stdc++.h>

using namespace std;

int op[2] = {1, -1};

string mcs(string s) {
    int cnt = 0, k = 0;
    s = s.substr(1, s.size() - 2);
    vector<string> bucket;
    for (int i = 0; i < (int)s.size() - 1; ++i) {
        cnt += op[s[i] - '0'];
        if (cnt == 0) bucket.push_back(mcs(s.substr(k, i - k + 1))), k = i + 1;
    }
    if (k) bucket.push_back(mcs(s.substr(k)));
    else bucket.push_back(s.substr(k));
    sort(bucket.begin(), bucket.end());
    string ans;
    for (const string &i : bucket) ans += i;
    return "0" + ans + "1";
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T; cin >> T;
    while (T--) {
        string a, b; cin >> a >> b;
        a = mcs("0" + a + "1"), b = mcs("0" + b + "1");
        puts(a == b ? "same" : "different");
    }
    return 0;
}
```
