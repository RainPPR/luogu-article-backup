---
title: P5343 【XR-1】分块 题解
date: 1710040130
description: 朴素算法很简单： 先处理出来所有可用的块长，记为集合 S。 设 fi 表示总长为 i 的方案数，则 fisumjin Sfij。 因为每个块的长度都不大于 100，所以这个类似于线性递推。 我们大体转化一
author: 371511
---

朴素算法很简单：

先处理出来所有可用的块长，记为集合 $S$。

设 $f_i$ 表示总长为 $i$ 的方案数，则 $f_i=\sum_{j\in S}f_{i-j}$。

因为每个块的长度都不大于 $100$，所以这个类似于线性递推。

我们大体转化一下，即 $f_i=f_{i-1}g_1+\dots+f_{i-100}g_{100}$。

其中 $g_i$ 表示块长为 $i$ 是否可用，用 $0/1$ 表示。

发现 $g_i$ 是常数，因此可以用矩阵乘法优化线性递推。

具体的，

$$
\begin{bmatrix}
g_1&g_2&g_3&\dots&g_{99}&g_{100}\\
1&0&0&\dots&0&0\\
0&1&0&\dots&0&0\\
0&0&1&\dots&0&0\\
\dots&\dots&\dots&\dots&\dots&\dots\\
0&0&0&\dots&1&0\\
\end{bmatrix}
\begin{bmatrix}
f_{i-1}\\f_{i-2}\\f_{i-3}\\\dots\\f_{i-99}\\f_{i-100}
\end{bmatrix}=
\begin{bmatrix}
f_i\\f_{i-1}\\f_{i-2}\\\dots\\f_{i-98}\\f_{i-99}
\end{bmatrix}
$$

注意到负的下标下，$f$ 值为零；而 $f_0=1$，

因此可以直接让 $i=1$ 作为初始条件：

$$
\begin{bmatrix}
g_1&g_2&g_3&\dots&g_{99}&g_{100}\\
1&0&0&\dots&0&0\\
0&1&0&\dots&0&0\\
0&0&1&\dots&0&0\\
\dots&\dots&\dots&\dots&\dots&\dots\\
0&0&0&\dots&1&0\\
\end{bmatrix}^{n}
\begin{bmatrix}
1\\0\\0\\\dots\\0\\0
\end{bmatrix}=
\begin{bmatrix}
f_n\\f_{n-1}\\f_{n-2}\\\dots\\f_{n-98}\\f_{n-99}
\end{bmatrix}
$$

然后就很简单了。代码：

然而鱼鱼姐姐教给我了一个更加好玩的算法。

留个坑。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

using ll = long long;

constexpr int mod = 1e9 + 7;

vector<int> multiply(vector<int> &f, vector<int> &g, int n) {
	vector<int> h(n + 3 << 2);
	for (int i = 0; i <= n; ++i)
	for (int j = 0; j <= n; ++j)
	h[i + j] = (h[i + j] + 1ll * f[i] * g[j] % mod) % mod;
	return h;
}

int recur(vector<int> p, vector<int> q, int k, ll n) {
	vector<int> f, g, h(k + 1);
	for (; n; n >>= 1) {
		for (int i = 0; i <= k; ++i) h[i] = (i & 1) ? (mod - q[i]) : q[i];
		f = multiply(p, h, k), g = multiply(q, h, k);
		for (int i = 0; i <= k; ++i) q[i] = g[i << 1];
		for (int i = 0; i < k; ++i) p[i] = f[i << 1 | (n & 1)];
	} return p[0];
}

int solev(vector<int> &f, vector<int> &a, int k, ll n) {
	vector<int> q(k + 1); q[0] = 1;
	for (int i = 1; i <= k; ++i) q[i] = mod - f[i];
	a = multiply(a, q, k);
	a.resize(k + 1), a[k] = 0;
	return recur(a, q, k, n);
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	ll n; cin >> n;
	int p, q, x; vector<int> aa(101), bb(101), f(101);
	cin >> p; for (int i = 0; i < p; ++i) cin >> x, aa[x] = 1;
	cin >> q; for (int i = 0; i < q; ++i) cin >> x, bb[x] = 1;
	for (int i = 1; i <= 100; ++i) f[i] = aa[i] && bb[i];
	vector<int> a(101); a[0] = 1;
	for (int i = 1; i < 100 && i <= n; ++i) for (int j = 1; j <= i; ++j) a[i] = (a[i] + 1ll * f[j] * a[i - j] % mod) % mod;
	if (n < 100) cout << a[n] << endl, exit(0);
	cout << solev(f, a, 100, n) << endl;
	return 0;
}
```
