---
title: 题解：P10455 Genius Acm
date: 1716514741
description: 曾经写的倍增笔记里面有这道题，详细看：httpswwwcnblogscomRainPPRp18208160。

UPD 20240805：更新了上面的链接。

下面是题解，从上面我的笔记里面抄过来的（

 天才 ACM

考虑到，一
author: 371511
---

曾经写的倍增笔记里面有这道题，详细看：<https://www.cnblogs.com/RainPPR/p/18208160>。

UPD 20240805：更新了上面的链接。

下面是题解，从上面我的笔记里面抄过来的（

## 天才 ACM

考虑到，一个集合的校验值，一定是最大对最小，次大对次小。

随便举个例子，若 $a<b<c<d$，则

$$
(d-a)^2+(c-b)^2=a^2+b^2+c^2+d^2-2(ad+bc)\\
(b-a)^2+(d-c)^2=a^2+b^2+c^2+d^2-2(ab+cd)
$$

上式减下式，

$$
ab+cd-ad-bc=a(b-d)+c(d-b)=(c-a)(d-b)
$$

乘积为正数，即上式大于下式，即贪心可行且正确。

回归问题，容易总结出来：

对于左端点，找到最右的点，使得校验值小于限制的值。

考虑到计算校验值是 $\mathcal O(n\log n)$ 的，因此这里需要优化。

注意到和上面的题形式类似，可以倍增处理，

因为倍增的复杂度是 $\mathcal O(\log n)$ 的，因此整体复杂度为，

$$
\mathcal O(n\log^2n)
$$

不太可过，但是注意到每次右端点增加的时候，可以类似归并排序的合并。

于是复杂度降为，

$$
\mathcal O(n\log n)
$$

但是细节很多，本人采用了闭区间的写法，

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

using ll = long long;
constexpr int N = 1e6 + 10;

int n, m;
ll t;
int a[N], b[N];
int q[N];

bool getchk(int l, int r, int ad) {
	int lt = r - ad + 1;
    for (int i = lt; i <= r; ++i) b[i] = a[i];
    sort(b + lt, b + r + 1);
    int tot = 0, u = l, v = lt;
	while (u < lt && v <= r) {
		if (b[u] < b[v]) q[tot++] = b[u++];
		else q[tot++] = b[v++];
	}
	while (u < lt) q[tot++] = b[u++];
	while (v <= r) q[tot++] = b[v++];
	ll chk = 0;
	for (int i = 0, j = tot - 1, k = 1; k <= m && i < j; ++i, --j, ++k)
	chk += 1ll * (q[j] - q[i]) * (q[j] - q[i]);
	return chk <= t;
}

int getpos(int l) {
	int p = 1, k = l - 1;
	while (p) {
		if (k + p <= n && getchk(l, k + p, p)) {
			k = k + p, p <<= 1;
			for (int i = l; i <= k + p; ++i) b[i] = q[i - l];
		} else p >>= 1;
	} return k;
}

void solev() {
	cin >> n >> m >> t;
	for (int i = 1; i <= n; ++i) cin >> a[i];
	int l = 1, ans = 0;
	while (l <= n) l = getpos(l) + 1, ++ans;
	cout << ans << endl;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	int T; cin >> T;
	while (T--) solev();
	return 0;
}
```
