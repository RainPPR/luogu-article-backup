---
title: 题解：P11267 【MX-S5-T1】王国边缘
date: 1731129826
description: Tag：基环树，倍增。

先将每个点看为一个模 n 同余的一类点。

注意到我们可以把从每个点开始走 1 步的位置找出来。

容易联想到，这么连边，最终的图一定是一个内向基环森林。

那么走 k 次就是基环树上面走 k 步，可以简单的倍增解
author: 371511
---

Tag：基环树，倍增。

先将每个点看为一个模 $n$ 同余的一类点。

注意到我们可以把从每个点开始走 $1$ 步的位置找出来。

容易联想到，这么连边，最终的图一定是一个内向基环森林。

那么走 $k$ 次就是基环树上面走 $k$ 步，可以简单的倍增解决。

但是还要求目标点的原始编号，而不是同余后的。

发现可以给基环树的边权设置为，走过这条边之后加多少个 $n$。

也就是走这条边会绕着走多少个循环。

基环树倍增的同时，倍增一下边权即可，容易实现的。

```cpp
#include <bits/stdc++.h>

#define endl "\n"

using namespace std;

void Main();

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	return Main(), 0;
}

using ll = long long;

#define int ll

constexpr int mod = 1e9 + 7;

constexpr int N = 2e5 + 10;

int n, m;

int nxt[N][63], val[N][63];

int calc(int s, int k) {
	int w = ((s - 1) / n) % mod;
	s = (s - 1) % n + 1;
	while (k) {
		int u = __builtin_ctzll(k);
		w = (w + val[s][u]) % mod;
		s = nxt[s][u];
		k &= k - 1;
	}
	return (s + w * n % mod) % mod;
}

namespace graph {
	void add(int u, int v, int w = 0) {
		if (v > n)
			v -= n, w = 1;
		nxt[u][0] = v;
		val[u][0] = w % mod;
	}

	void init() {
		for (int k = 1; k < 63; ++k) {
			for (int i = 1; i <= n; ++i) {
				nxt[i][k] = nxt[nxt[i][k - 1]][k - 1];
				val[i][k] = (val[i][k - 1] + val[nxt[i][k - 1]][k - 1]) % mod;
			}
		}
	}
}

void init(string &str) {
	if (m < n) {
		str = "#" + str + str;
		vector<int> pre(2 * n + 1);
		for (int i = 1; i <= 2 * n; ++i)
			pre[i] = pre[i - 1] + (str[i] == '1');
		for (int i = 1; i <= n; ++i) {
			if (pre[i + m] - pre[i] == 0)
				graph::add(i, i + 1);
			else {
				auto it = lower_bound(pre.begin(), pre.end(), pre[i + m]);
				graph::add(i, it - pre.begin());
			}
		}
	}
	else {
		// m >= n
		str = "#" + str;
		vector<int> pre(n + 1);
		int last = -1, beg = -1;
		for (int i = n; i >= 1; --i) {
			if (str[i] == '1') {
				last = i;
				break;
			}
		}
		for (int i = 1; i <= n; ++i) {
			if (str[i] == '1') {
				if (beg == -1)
					beg = i;
				last = i;
			}
			pre[i] = last;
		}
		for (int i = 1; i <= n; ++i) {
			int j = (i + m - 1) % n + 1;
			graph::add(i, pre[j], (i + m - 1) / n - (j < beg));
		}
	}
	graph::init();
}

void Main() {
	int q;
	string str;
	cin >> n >> m >> q;
	cin >> str;
	if (count(str.begin(), str.end(), '0') == n) {
		while (q--) {
			int s, k;
			cin >> s >> k;
			cout << (s + k) % mod << endl;
		}
		return;
	}
	if (count(str.begin(), str.end(), '1') == n) {
		m %= mod;
		while (q--) {
			int s, k;
			cin >> s >> k;
			k %= mod;
			cout << (s + k * m % mod) % mod << endl;
		}
		return;
	}
	init(str);
	while (q--) {
		int s, k;
		cin >> s >> k;
		cout << calc(s, k) << endl;
	}
}
```

代码里面特判了全 $0$ 的情况，因为在 `init` 中的大 `else` 没有 $1$ 会寄；特判全 $1$ 是卡常。
