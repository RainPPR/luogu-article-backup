---
title: 题解：P11063 【MX-X4-T3】「Jason-1」数对变换
date: 1726491114
description: 注意到可以进行操作：  defop12underrightarrowscriptsizetexttt 1 2  deffloor1leftlfloor1rightrfloor 1top2
author: 371511
---

注意到可以进行操作：

$$
\def\op#1#2{\underrightarrow{\scriptsize\texttt{ #1 #2 }}}
\def\floor#1{\left\lfloor{#1}\right\rfloor}
(1,t)\op2{cd}\left(cd,\floor{\dfrac t{cd}}\right)\op1{d}\left(c,d\floor{\dfrac t{cd}}\right)
$$

那么我们只需要令 $cd\le t<2cd$ 即可结束，于是考虑构造。

$$
\def\op#1#2{\underrightarrow{\scriptsize\texttt{ #1 #2 }}}
\def\floor#1{\left\lfloor{#1}\right\rfloor}
(a,b)\op1{a}(1,ab)\op2{k}\left(k,\floor{\dfrac{ab}k}\right)\op1{k}\left(1,k\floor{\dfrac{ab}k}\right)
$$

其中我们要每次选择一个合适的 $k$，使得最终落到要求区间即可。

---

我们考虑观察函数，

$$
\def\floor#1{\left\lfloor{#1}\right\rfloor}
f(x)=x\floor{\dfrac ax},a=\text{const.}
$$

的性质，我们使用 GeoGebra，易得：

![](https://cdn.luogu.com.cn/upload/image_hosting/0s4k9osr.png)

容易发现，在取 $x=a/2$ **附近**的时候，可以取到最小值 $a/2$ **左右**。

具体的，我们令 $x=\lfloor a/2\rfloor+1$ 的时候，可以取到整数时的最小值！

---

考虑将函数性质带入最上面的迭代中。

注意到每次会减少略小于 $ab/2$ 的大小，这意味着我们 ***一定*** 可以取到目标区间。

这是真的吗？考虑特例！

+ $c=d=1$：

  + 此时只有 $a=b=1$ 才会有解。
 
  + 因为缩小是无法缩到上面图像描述的**看似**最小值的。
 
  + 也就是说，我们在 $ab>1$ 的时候，永远无法缩到 $1$。
 
+ $ab<cd$：

  + 注意到每次操作一定会使 $ab$ 减小。
 
  + 那么，若 $ab<cd$ 一定无解，因为我们没法变大了。

否则，一定有解，按照上面的步骤求解即可，然后你会得到 $50\text{pts}$ 做法。

```cpp
int a, b, c, d;

vector<pair<int, int>> ans;

void work(int x, int y) {
	ans.emplace_back(x, y);
	if (x == 1) {
		a /= y;
		b *= y;
	}
	else {
		b /= y;
		a *= y;
	}
}

void print() {
	cout << ans.size() << endl;
	for (auto t : ans)
		cout << t.first << " " << t.second << endl;
}

int Main(int _) {
	_ = _;
	cin >> a >> b >> c >> d;
	if (a * b < c * d)
		return -1;
	if (c * d == 1)
		return (a * b == 1) - 1;
	ans.clear(), work(1, a);
	while (b >= 2 * c * d) {
		int v = b / 2 + 1;
		work(2, v);
		work(1, v);
	}
	work(2, c * d);
	work(1, d);
	return print(), 1;
}

void Main() {
	int T;
	cin >> T;
	while (T--) {
		int res = Main(T);
		if (res != 1)
			cout << res << endl;
	}
}
```

---


考虑优化。

容易发现我们两次操作才会进行一个有效的减小，这是很浪费的。

容易想到我们直接对着一个非 $1$ 的消去，否则消另外一个即可，代码：

```cpp
int Main(int _) {
	_ = _;
	cin >> a >> b >> c >> d;
	if (a * b < c * d)
		return -1;
	if (c * d == 1)
		return (a * b == 1) - 1;
	ans.clear(), work(1, a);
	while (a * b >= 2 * c * d) {
		int v = a * b / 2 + 1;
		if (a != 1)
			work(1, v);
		else
			work(2, v);
	}
	if (a != 1)
		work(1, a);
	work(2, c * d);
	work(1, d);
	return print(), 1;
}
```
