---
title: 题解：AT_abc374_e [ABC374E] Sensor Optimization Dilemma 2
date: 1728182615
description: b'5oCd6Lev5p2l6Ieq44GT44Gf44Gk44GM44KB77yIa290YXRzdWdhbWXvvInlpKfkvaznmoTop4bpopHjgIIKCi0tLQoK6aaW5YWI77yM5a655piT5oOz5Yiw5oiR5Lus5Y+v5Lul5LqM5YiG562U5qGIICRXJO+8iOacgOWkp+eUn+S6p+WKm++8ie+8jOWvueS6juavj+S4gOS4quW3peeoi+S7pOeUn+S6p+WKm+aAu+WSjCAkXGdlIFck77yM54S25ZCO6K6h566X5Ye65p2l5omA6ZyA6Iqx6LS577yM5Yik5pat5piv5ZCmICRcbGUgWCQg5Y2z5Y+v44CCCgrlr7nkuo7kuIDkuKrlt6XnqIsgJFxsYW5nbGU='
author: 371511
---

思路来自こたつがめ（kotatsugame）大佬的视频。

---

首先，容易想到我们可以二分答案 $W$（最大生产力），对于每一个工程令生产力总和 $\ge W$，然后计算出来所需花费，判断是否 $\le X$ 即可。

对于一个工程 $\langle A,P,B,Q\rangle$，我们需要找到两个机器的生产力 $x,y\ge0$ 满足 $Ax+By\ge W$ 的条件下，最小化 $Px+Qy$ 的值。

$$
\begin{aligned}
&Ax+By\ge W\\
\Longrightarrow\quad&y\ge\left\lceil\dfrac{W-Ax}{B}\right\rceil\\
\Longrightarrow\quad&y=\max\left(0,\left\lceil\dfrac{W-Ax}{B}\right\rceil\right)
\end{aligned}
$$

不妨使用带余除法分解 $x$：

$$
x=x_1B+x_0\quad(0\le x_0<B)
$$

那么，使用顶函数的性质：

$$
\begin{aligned}
y&=\max\left(0,\left\lceil\dfrac{W-Ax}{B}\right\rceil\right)\\
&=\max\left(0,\left\lceil\dfrac{W-Ax_0}{B}-Ax_1\right\rceil\right)\\
&=\max\left(0,\left\lceil\dfrac{W-Ax_0}{B}\right\rceil-Ax_1\right)\\
\end{aligned}
$$

不妨记：

$$
w=\left\lceil\dfrac{W-Ax_0}{B}\right\rceil
$$

则：

$$
y=\max\left(0,w-Ax_1\right)
$$

---

我们考虑直接枚举 $x_0$ 为常数并钦定后面的式子 $\ge0$，

$$
w-Ax_1\ge0 \iff x_1\le\left\lfloor\dfrac{w}{A}\right\rfloor
$$

此时：

$$
\begin{aligned}
Px+Qy&=Px_0+Qw+PBx_1-QAx_1\\
&=Px_0+Qw+(PB-QA)x_1
\end{aligned}
$$

是关于 $x_1$ 的一次函数，不妨两个端点都直接记入贡献。

---

然后考虑后面的式子 $\le0$ 即：

$$
x_1>\left\lfloor\dfrac{w}{A}\right\rfloor=\left\lfloor\dfrac{w}{A}\right\rfloor+1
$$

那么：

$$
Px+Qy=P(x_0+Bx_1)
$$

---

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl "\n"

using ll = long long;

#define int ll

int n, x;

struct pt {
    int a, p;
    int b, q;
};

vector<pt> process;

bool check(int W) {
    int rest = x;
    for (auto [a, p, b, q] : process) {
        int cost = rest + 1;
        for (int x0 = 0; x0 < b; ++x0) {
            int w = (max(0ll, W - a * x0) + b - 1) / b;
            int base = p * x0 + q * w;
            int add = p * b - q * a;
            int lx = 0, rx = w / a;
            cost = min({
                cost,
                p * (x0 + b * (rx + 1)),
                base + add * lx,
                base + add * rx
            });
        }
        if ((rest -= cost) < 0)
            return false;
    }
    return true;
}

void Main() {
    cin >> n >> x;
    process.resize(n);
    for (auto &[a, p, b, q] : process)
        cin >> a >> p >> b >> q;
    int l = 0, r = 1e9;
    int ans = -1;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (check(mid))
            ans = mid, l = mid + 1;
        else
            r = mid - 1;
    }
    cout << ans << endl;
    return;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    return Main(), 0;
}

```
