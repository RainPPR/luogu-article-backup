---
title: 题解：AT_abc354_f [ABC354F] Useless for LIS
date: 1716119982
description: 这道题可以从多方面来考虑，我们一层层递进：

 一个数，若存在于序列的最长上升子序列中，其有什么特性。
 一个序列的最长上升子序列有什么特性。
 一个序列，除了其最长上升子序列的长度外，我们还可以知道什么。

先不说那么复杂，先考虑最朴素的 LIS 
author: 371511
---

这道题可以从多方面来考虑，我们一层层递进：

+ 一个数，若存在于序列的最长上升子序列中，其有什么特性。
+ 一个序列的最长上升子序列有什么特性。
+ 一个序列，除了其最长上升子序列的长度外，我们还可以知道什么。

先不说那么复杂，先考虑最朴素的 LIS 如何处理。

显然，设 $f(x)$ 表示以 $x$ 结尾的 LIS 最大长度，有，

$$
f(i)=\max_{j<i}\{f(j)\times[A_j<A_i]\}+1
$$

直接这么做，复杂度是 $\mathcal O(n^2)$ 的，考虑优化。

容易发现，当我们考虑一个数一个数的加入的时候，我们计入贡献的为：

已经处理过的，数字小于其本身的中，$f$ 最大的。

于是我们考虑一遍插入，一遍计算 $f(i)$，这就是一个橙题（的加强版），

我们建立一个有序数组，然后贪心的插入。

对于若干的长度相同的结尾，我们只需要保留更小的那个。

只需要 lowerbound 一下即可（LIS 的细节见下面代码）。

即 [B3637 最长上升子序列](https://www.luogu.com.cn/problem/B3637)（当然这道题可以 $\mathcal O(n^2)$ 的做）。

然后考虑如何判断一个数是否在序列的最长上升子序列中。

考虑上面我提出的三个问题。

显然，如果一个数 $A_x$ 在一个最长上升子序列长度为 $m$ 的序列 $A$ 中，

那么由它构成的最长上升子序列，可以分割为两部分，分别是：

+ 以它结尾的最长上升子序列，和
+ 以它开头的最长下降子序列。

考虑分别处理，我们先处理出最长上升子序列，记为 $\mathit{pre}_x$.

然后考虑后面的，也很好做：

为了方便，我们只需要将原数组取反再逆序，求解最长上升子序列。

那么再逆序，得到的就是其最长下降子序列，记为 $\mathit{suf}_x$.

那么，判断 $A_x$ 是否在序列 $A$ 的 LIS 里面，其充要条件为，

$$
\mathit{pre}_x+\mathit{suf}_x-1=m
$$

原理就是将这两个序列强行拼在一起。

注意到 $A_x$ 算了两次，一次在开头，一次在结尾，于是再减去 $1$。

我们最后梳理一下：

+ 计算出序列 $A$ 的，以 $A_x$ 结尾的最长上升子序列，
+ 计算出序列 $A$ 的，以 $A_x$ 开头的最长下降子序列，
+ 若满足（上面的式子），则说明 $x$ 在 $A$ 的 LIS 中。

代码依旧很简单：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

template<typename tp>
istream& operator >>(istream &in, vector<tp> &a) {
    for (tp &t : a) in >> t;
    return in;
}

template<typename tp>
ostream& operator <<(ostream &out, vector<tp> &a) {
    for (auto i : a) out << i << " ";
    return out;
}

#define range(x) x.begin(), x.end()
#define lowbit(x) ((x) & -(x))

constexpr int N = 2e5 + 10;

int n, res;

vector<int> lis(vector<int> &a, int &e) {
    vector<int> dp(n, 2e9), ret(n);
    dp[0] = -2e9, e = 0;
    for (int i = 0; i < n; ++i) {
        int id = lower_bound(dp.begin(), dp.end(), a[i]) - dp.begin();
        dp[id] = a[i], ret[i] = id;
        e = max(e, ret[i]);
    } return ret;
}

void solev() {
    cin >> n;
    vector<int> a(n), pre, suf, r;
    cin >> a;
    pre = lis(a, res);
    reverse(range(a)); for (auto &i : a) i = -i;
    suf = lis(a, res);
    for (int i = 0; i < n; ++i) if (pre[i] + suf[n - i - 1] - 1 == res) r.push_back(i + 1);
    cout << r.size() << endl << r << endl;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T; cin >> T;
    while (T--) solev();
    return 0;
}
```

树状数组的版本，注意离散化：

用树状数组维护，$s_i$ 表示，当前状态下，$A_k\le i$ 中的最大的 $f$。

这种下标转为值、值转为下标来维护的思想，在数据结构和状态设计中常常出现。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'

template<typename tp>
istream& operator >>(istream &in, vector<tp> &a) {
    for (tp &t : a) in >> t;
    return in;
}

template<typename tp>
ostream& operator <<(ostream &out, vector<tp> &a) {
    for (auto i : a) out << i << " ";
    return out;
}

#define range(x) x.begin(), x.end()
#define lowbit(x) ((x) & -(x))

constexpr int N = 2e5 + 10;

int n, res, s[N];

void modify(int x, int v) {
    for (; x <= n; x += lowbit(x)) s[x] = max(s[x], v);
}

int query(int x) {
    int r = 0;
    for (; x; x -= lowbit(x)) r = max(r, s[x]);
    return r;
}

vector<int> lis(vector<int> &a, int &e) {
    e = 1; vector<int> p(a), r(a);
    for (int i = 1; i <= n; ++i) s[i] = 0;
    sort(range(p)), p.erase(unique(range(p)), p.end());
    for (int i = 0; i < n; ++i) {
        int t = lower_bound(range(p), a[i]) - p.begin() + 1;
        r[i] = query(t) + 1, modify(t + 1, r[i]);
        e = max(e, r[i]);
    } return r;
}

void solev() {
    cin >> n;
    vector<int> a(n), pre, suf, r;
    cin >> a;
    pre = lis(a, res);
    reverse(range(a)); for (auto &i : a) i = -i;
    suf = lis(a, res);
    for (int i = 0; i < n; ++i) if (pre[i] + suf[n - i - 1] - 1 == res) r.push_back(i + 1);
    cout << r.size() << endl << r << endl;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T; cin >> T;
    while (T--) solev();
    return 0;
}
```
