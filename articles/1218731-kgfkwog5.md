---
title: 阅读 论现代硬件上的常数优化 宋佳兴
date: 1721691338
description:  前缀和

前缀和写，ai  1  ai 要比，ai  ai  1 更好。

这是因为 O2 对后者的优化是不到位的。

这个问题在 GCC 12 修复，NOILinux 中的 GCC 9 是未修复的版本。


author: 1218731
---

## 前缀和

前缀和写，`a[i + 1] += a[i];` 要比，`a[i] += a[i - 1];` 更好。

这是因为 O2 对后者的优化是不到位的。

这个问题在 GCC 12 修复，NOI-Linux 中的 GCC 9 是未修复的版本。

## 循环展开

略。

编译指令 `-funroll-loops`，或，

```cpp
#pragma GCC unroll 4
```

## 循环融合

将需要访问同一数组的循环融合在一起，其目标是减少内存读写次数。

常用于动态规划的转移，常配用循环展开。

## 去除分支

对于总是执行或者不执行的 `if` 语句，

可以使用 `__builtin_expect` 函数告诉编译器 `if` 语句的执行倾向，

```cpp
if (__builtin_expect(x < y,0)) x = y; // 几乎总是不执行
if (__builtin_expect(x > y, 1)) x = y; // 几乎总是执行
```

如果 `if` 语句后面的语句很少，那么可以考虑去除这些分支。

另外，使用无符号比较，可能会更快或更慢，在 GCC 12 后才确保更快。

好的写法：

1. 定义变量，然后使用 `if` 语句，

```cpp
int a = ..., b = ...;
if (a < b) // do something ...
```

2. 定义变量，然后使用三目运算，

```cpp
int a = ..., b = ...;
int c = a > b ? a : b;
```

3. 使用 `min/max` 函数。

错误的写法：

```cpp
void checkMax(int &a, int b) {
	if (a < b) a = b;
}
```

## 更改对齐方式

使用关键字 `alignas`：

+ `alignas(expression)`：表示指定对齐大小，需要为 $2$ 的整数次幂；

+ `alignas(type-id)`：指定同于该类型的对齐方式，传入一个类型名称。

可以对 `struct`、`class` 或变量声明使用 `alignas` 说明符。

```cpp
struct alignas(8) S1 {
	int x;
};

struct alignas(double) S2 {
	int x;
};

// alignas(0) ignored
union alignas(0) U1 {
	int i;
	float f;
};
```

注意：

+ 将忽略小于最小对齐要求的 `alignas` 值（始终忽略 $0$ 值）。

+ 增加对齐要求通常能提高性能，但也可能导致内存浪费。

## 位运算

使用 `&&` 和 `||` 会产生分支，

如果分支是不可预测的，可以替换为位运算 `&` 和 `|`。

### Counting Trailing Zeros

```cpp
int __builtin_ctz(unsigned int);
int __builtin_ctzl(unsigned long);
int __builtin_ctzll(unsigned long long);
```

返回二进制表示中末尾 $0$ 的个数。

例如 $26=(11010)_2$，$\operatorname{ctz}(26)=1$。

用途：枚举子集，

```cpp
while (mask) {
	int i = __builtin_ctz(mast);
	// ...
	mask &= mask - 1;
}
```

注意传入 $0$ 是未定义的。

额外：Count Leading Zeros（$\operatorname{clz}$）返回的是左边 $0$ 的个数，想不到什么用处。

### Find First Set

```cpp
int __builtin_ffs(unsigned int);
int __builtin_ffsl(unsigned long);
int __builtin_ffsll(unsigned long long);
```

返回二进制表示中最低非 $0$ 位下标。

例如 $26=(11010)_2$，$\operatorname{ctz}(26)=2$。

从后往前，下标从 $1$ 开始计数；传入 $0$ 返回 $0$。

除去 $0$，满足 $\operatorname{ffs}(x)=\operatorname{ctz}(x)+1$。

### Population Count

```cpp
int __builtin_popcount(unsigned int);
int __builtin_popcountl(unsigned long);
int __builtin_popcountll(unsigned long long);
```

因为不能使用，

```cpp
#pragma target("popcnt")
```

因此这个函数很慢，于是我们，

对 $0\sim 65535$ 预处理 popcount，然后每次读取 $16$ 位查表。

### Parity

```cpp
int __builtin_parity(unsigned int);
int __builtin_parityl(unsigned long);
int __builtin_parityll(unsigned long long);
```

返回二进制表示中 $1$ 的个数的奇偶性。

等价于，$\operatorname{parity}(x)=\operatorname{popcount}(x)\operatorname{\&}1$。

## 内置函数

### C 标准库内建函数

几乎所有 C 语言的标准函数都有 `__builtin` 版本，例如，

+ 内存操作：`memcpy` `memset` `memcmp`；

+ 数学函数：`sin` `cos` `tan` `abs` `exp`；

+ 字符串：`strcmp` `strcpy` `strlen`；

+ 输入输出：`printf` `scanf` `putchar` `puts`。

### 其他内置函数

期待：

```cpp
#define expect(x, v)	__builtin_expect(x, v)			// 期待 x 为 v
#define likely(x)		expect(!!(x), 1)				// 期待 x 为真
#define unlikely(x)		expect(!!(x), 0)				// 期待 x 为假
```

认定：

```cpp
#define unreachable()	__builtin_unreachable()			// 认定为永远不执行的分支 
#define assume(x)		({ if (!(x)) unreachable(); })	// 认定 x 永远为真
```

预读取：

```cpp
void __builtin_prefetch(const void *ptr, int rw, int locality)
```

参数说明：

+ `ptr`：要预读取内存的指针；

+ `rw` 访问类型：$0$ 只读，$1$ 读写；

+ `locality` 数据局部性：$0$ 只读一次，$3$ 重复的经常读，中间递增。

PS：这里使用了另一个 GCC 私活：

```cpp
#define func(x) ({ ... ; y; })
```

表示执行完 `...` 后返回 `y` 作为这个表达式的值。

## 使用 $\texttt{long long}$ 替代 $\texttt{pair<int, int>}$

新环境是 64 位的，因此 64 位的指令通常会和 32 位一样快。

因此：

+ 使用一个 $\texttt{long long}$ 通常会比两个 $\texttt{int}$ 快。

+ `long long = pair<int, unsigned int>`。

+ `unsigned long long = pair<unsigned int, unsigned int>`。

+ `long long` 可以一次模拟两个 `int` 的加法，前提是没有负数且没有溢出。

## 空间局部性

目标是让访问的数据在空间上连续，从而减少换成行未命中的次数。

+ 内存布局：高维数组哪一位在前面，多个数组 vs 一个结构体。

+ 访问顺序：多个 `for` 循环，需要确定顺序以使地址尽可能连续。

例如，

+ ST 表先枚举 $k$ 再枚举 $i$；

+ 部分区间 DP 先枚举 $l$ 再枚举 $k$ 后枚举 $r$。

必使用 short 压缩空间，在某些情况下可能会带来性能损失。

## 时间局部性

让适合缓存的数据在一段时间内反复访问。

例子就是，滚动数组一维通常优于二维。

另一种方法是分块卡进缓存，

+ L1、L2 缓存大小的 $50\%\sim80\%$；

+ L3 缓存的 $1/3$ 以下。

复用寄存器，每次枚举小块，在小块内处理。

截止 $2024$ 年，NOI 使用的评测机配置是，

| Intel Core i7-8700K Processor | $\texttt{int}$ | $\texttt{long long}$ |
| - | -: | -: |
| Cache L1: 64 KB (per core) | $10\ 000$ | $5\ 000$ |
| Cache L2: 256 KB (per core) | $40\ 000$ | $20\ 000$ |
| Cache L3: 12 MB (shared) | $1\ 000\ 000$ | $500\ 000$ |

大约对应右边的数组大小。

## 树的重新编号

### 按照 DFS 序重新编号

可以快速遍历子树，

$$
\mathit{st}_u\sim \mathit{ed}_u(\mathit{st}_u+\mathit{siz}_u-1)
$$

### 按照重链剖分 DFS 序重新编号

任意一条链可以拆分为 $\mathcal O(\log n)$ 个区间。

这样即使是 for 循环枚举也可能更快。

### 按照 BFS 序重新编号

此时，$\mathit{fa}_u$ 数据单调不减，因此可以非递归处理。

自底向上，

```cpp
for (int u = n; u >= 2; --u)
	dp[fa[u]] = max(dp[fa[u]], dp[u] + 1);
```

自顶向下，

```cpp
for (int u = 2; u <= n; ++u) {
	// ...
}
```

## 高效使用 STL

### $\texttt{vector}$

+ `reserve(n)` 预分配 $n$ 的容量，这样 `push_back` 就不会重新分配内存。

+ `emplace_back(...)` 可定义构造函数，只有在内部空间占用很大时，才会明显更快。

+ `A = move(B);` 表示 B 不使用后的快速移动，之后 B 未定义。

### $\texttt{priority\_queue}$

+ 构造函数是 $\mathcal O(n)$ 的，即线性构造堆算法。

+ `top` 函数是 $\mathcal O(1)$ 的。

+ 两个 `priority_queue` 对顶可以实现可删堆，比 `multiset` 更好。

### $\texttt{set / map}$

+ `insert(x)` 返回插入的迭代器，复杂度 $\mathcal O(\log n)$。

+ `erase(it)` 删除一个迭代器，返回 `next(it)` 且复杂度 $\mathcal O(1)$。

	+ 因此，值域很小时，可以开一个数组记录每个值的迭代器。
 
+ `insert(it, x)` 在 `it` 迭代器之前插入，复杂度 $\mathcal O(1)$。

+ `++it, --it` 复杂度 $\mathcal O(\log n)$ 常数很小。

### $\texttt{unordered\_map}$

`__gnu_pbds::gp_hash_table` 远快于 `unordered_map`。

他的唯一不足是哈希函数不合理，因此可以使用自定义哈希函数。

## 取模优化

### 取模时使用常量

```cpp
#define MOD 998244353
constexpr int mod = 1e9 + 7;
```

### 减少取模次数

只要没爆 `ull` 就不要频繁取模，例如 `a * b + c * d`。

另外，使用，

```cpp
void inc(int &a, int b) {
	a += b;
	if (a >= P) a -= P;
}
```

可能会更快或更慢（化成分支）。

### 使用无符号整数

理由：

+ 无符号取模更快，因为处理负数取模很复杂；

+ 从 `uint -> ull` 通常很快，但是 `int -> ll` 是需要很多操作的。

+ 注意：从 `ull -> uint` 需要高位清零，因此临时保留应始终使用 `ull`。

### 使用较大数据类型暂存

一般模数不会到类型极限，因此，

频繁取模的 `u64` 比取模一次的 `u128` 通常要快。

注意到 `u128` 是两个 64 位模拟出来的，

运算比 `u64` 慢，但是代价是值得的，因为取模更慢。

```cpp
u128 tmp = 0;
for (int i = 0; i < n; ++i)
	tmp += (ull)a[i] * b[i];
tmp %= MOD;
```

另外，`(u128)A * B` 其实很快，因为它会被编译为 64 位运算。

### 打断取模链

```cpp
auto res = (u64) a * b % P * c % p * d % P;
```

使用分治型合并，

```cpp
auto L = (u64) a * b % P;
auto R = (u64) c * d % P;
auto res = L * R % P;
```

更长的，可以循环展开。

### 浮点数注意

+ 存在浮点数时不要使用 `u64`，因为无符号和浮点数相互转化较慢。

+ $10^{18}$ 级别的浮点数需要使用 `long double`。

## 等位信息捆绑

如果数组 $A,B$ 会经常同时访问 $A_i,B_i$，那么就可以开一个结构体捆绑起来。

常用于树状数组 / 线段树。

## 计算对数函数

使用 `__lg(x)` 替代 `log2(x)`。

前者返回严格的整数数值，而后者浮点数显然慢且有精度误差。

还有更好的实现：`31 ^ __builtin_clz(x)` 但是不好记。

## 计算最大公因数

使用 Binary GCD 算法，

$$
\gcd(a,b)=\begin{cases}
2\gcd(a/2,b/2)\\
gcd(a/2,b)\\
\gcd(|a-b|,\min(a,b))
\end{cases}
$$

公式省去后面，除二为偶数，否则为奇数。

于是，我们实现，

+ 将 $a,b$ 中的 $2$ 除尽，

+ 递归，注意到减法绝对值会再次产生偶数，除去即可。

+ 注意到 $\pm x$ 的 $\operatorname{ctz}$ 是相同的，因此不需要取绝对值。

```cpp
#define ctz(x) __builtin_ctz(x)
#define clz(x) __builtin_clz(x)

int gcd(int a, int b) {
	if (!a | !b) return a + b;
	int az = ctz(a), bz = ctz(b), z = min(az, bz);
	a >>= az, b >>= bz;
	while (a != b) {
		int diff = b - a;
		az = ctz(diff);
		b = min(a, b), a = abs(diff) >> az;
	}
	return a << z;
}
```

## 补充

### $\texttt{inline}$：内联

函数内联在开 O2 的情况下通常由编译器自动完成。

结构体定义中的 `inline` 完全是多余的，则完全不必声明为内联。

如果不开 O2 则使用 `inline` 也不会让编译器真正内联。

### $\texttt{register}$：寄存器建议

现代编译器会直接忽略你的 `register` 关键字。

此关键字于 C++11 被弃用，于 C++17 被删除。
