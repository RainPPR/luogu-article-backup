---
title: 题解：P10465 双端队列
date: 1716865776
description: 注意到，最后的双端队列只能按照一个顺序拼接，因此：  最终的双端队列中的数，一定是单调递增的。  最终的若干个双端队列，按照一定的顺序，一定是首位相接单调递增的。 我们考虑，这几个双端队列有什么性质。 注意到，我们把排序后的数组，分成若干段，这
author: 371511
---

注意到，最后的双端队列只能按照一个顺序拼接，因此：

+ 最终的双端队列中的数，一定是单调递增的。

+ 最终的若干个双端队列，按照一定的顺序，一定是首位相接单调递增的。

我们考虑，这几个双端队列有什么性质。

注意到，我们把排序后的数组，分成若干段，这每一段：

+ 元素在原数组中的下标（用 $\mathit{id}$ 表示）一定是，先下降再上升的谷形。

那么，这个每一个谷，都可以用一个双端队列存储，问题转化为，

将排序好的数列，分为若干段，最小化段数，使得每一段的 $\mathit{id}$ 为谷形。

但是，注意到原数组中可能存在相同的数字，考虑如何处理，容易得出：

+ 原数组中，相同的数字，下标单调的存放，一定不劣。

因为，一次由上升转为下降，就需要多一段，这是我们不希望的。

于是，我们分类讨论，

+ 如果现在处于下降趋势，
	+ 如果当前段加入后，能维持下降，那么加入；
    + 否则，将趋势转为上升，然后加入。
+ 如果现在处于上升趋势，
	+ 如果当前段加入后，能维持上升，那么加入；
    + 否则，将趋势转为下降，加入后答案加一。

这里考虑到，如果不按照这个趋势来，那么后面的区间再加入，此时答案一定更大，

而后面的区间不会影响到其再后面的答案，因此贪心正确。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define endl '\n'
#define range(x) (x).begin(), (x).end()

struct emm {
    int v, id;
    friend bool operator <(const emm &a, const emm &b) {
        return a.v == b.v ? a.id < b.id : a.v < b.v;
    }
};

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int n; cin >> n; vector<emm> a(n);
    for (int i = 0; i < n; ++i) a[i].id = i + 1, cin >> a[i].v;
    sort(range(a));
    int cnt = 1, mx = 1e9, dir = -1;
    for (int l = 0, r = 0; l < n; l = r) {
        while (r < n && a[l].v == a[r].v) ++r;
        int u = a[l].id, v = a[r - 1].id;
        if (dir == -1) {
            if (v < mx) mx = u;
            else mx = v, dir = 1;
        }
        else if (dir == 1) {
            if (u > mx) mx = v;
            else mx = u, dir = -1, ++cnt;
        }
    }
    cout << cnt << endl;
    return 0;
}
```

这里面用到了经典的将区间分为值相同的若干段的方法。
