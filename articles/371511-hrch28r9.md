---
title: 题解：P10460 防线
date: 1716771072
description: 我们注意到，这个题很容易注意到，注意到 mx 首先，一眼序列二分， 注意到，如果位置 p 是奇数，其他位置显然都是偶数。 那么，任何一个区间 lr 满足，  lle qle r  的区间和都是奇数，这是充要条件。
author: 371511
---

我们注意到，这个题很容易注意到，注意到 mx~!

首先，一眼序列二分，

注意到，如果位置 $p$ 是奇数，其他位置显然都是偶数。

那么，任何一个区间 $[l,r]$ 满足，

$$
l\le q\le r
$$

的区间和都是奇数，这是充要条件。

于是，这个序列满足可二分性，具体的，

先判断，如果整个区间的和都是偶数，那么输出 `There's no weakness.`。

否则，序列二分，具体的，

+ 记区间 $[l,r]$ 中有答案，记 $\mathit{mid}=(l+r)/2$，
+ 如果区间 $[l,\mathit{mid}]$ 和为奇数，那么奇数项存在于该区间中，
+ 否则，奇数项存在于区间 $[\mathit{mid}+1,r]$ 中，二分即可。

注意到，没有了哦（

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

#define int ll
#define endl '\n'

#define return(x) { x; return; }

constexpr int N = 2e5 + 10;

int n;

struct emm {
	int s, e, d;
} a[N];

int calc(int l, int r) {
	int cnt = 0;
	for (int i = 1; i <= n; ++i) {
		int s = a[i].s, e = a[i].e, d = a[i].d;
		if (s < l) s += (l - s + d - 1) / d * d;
		e = min(e, r);
		if (s > e) continue;
		cnt += (e - s + 1 + d - 1) / d;
	}
	return cnt;
}

void solev() {
	cin >> n;
	for (int i = 1; i <= n; ++i) cin >> a[i].s >> a[i].e >> a[i].d;
	int l = 0, r = 1ll << 31;
	if (calc(l, r) % 2 == 0) return(puts("There's no weakness."));
	while (l < r) {
		int mid = l + r >> 1;
		if (calc(l, mid) & 1) r = mid;
		else l = mid + 1;
	}
	cout << l << " " << calc(l, r) << endl;
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	int T; cin >> T; while (T--) solev();
	return 0;
}
```
