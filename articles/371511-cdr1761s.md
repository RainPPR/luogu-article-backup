---
title: [The 2023 ICPC AROC I] I Pa?sWorD  题解
date: 1698403873
description: 宣传：httpswwwcnblogscomRainPPRarticlessolutionicpc2023aroc1ihtml  朴素思路 最朴素的思路其实很简单： 设 fmathitposmathitla
author: 371511
---

宣传：<https://www.cnblogs.com/RainPPR/articles/solution-icpc2023aroc-1i.html>

## 朴素思路

最朴素的思路其实很简单：

设 $f(\mathit{pos},\mathit{last},0/1,0/1,0/1)$ 表示 $\mathit{pos}$ 位置，上一个为 $\mathit{last}$，是否有大写字母、小写字母、数字。

用类似数位 DP 的转移方式，记忆化搜索即可。

代码：<https://www.luogu.com.cn/paste/u32u6v7t>

数组开到了 $10^5\times62\times8$，内存超限了，考虑滚动数组优化。

## 空间优化

挺简单的，代码：<https://www.luogu.com.cn/paste/po3ou8ec>

但是，时间复杂度呢？可知，总字符数 $3\times10^5$，可用字符集大小 $62$，总状态数 $1.248\times10^8$，不可过。

## 时间优化

展开一下转移：

$$
\begin{array}{l}
f(\mathit{pos},\mathit{this},a,b,c):\\\quad
a\rightarrow[\texttt{a},\texttt{z}],b\rightarrow[\texttt{A},\texttt{Z}],c\rightarrow[\texttt{0},\texttt{9}]\\\\
\mathit{if}\space s_{\mathit{pos}}\in[\texttt{a},\texttt{z}]\rightarrow(a=1):\\\quad
f(\mathit{pos},\mathit{this},1,b,c)=\sum_jf(\mathit{pos}-1,j,0/1,b,c)-f(\mathit{pos}-1,\mathit{this},0/1,b,c)\\\\
\mathit{if}\space s_{\mathit{pos}}\in[\texttt{A},\texttt{Z}]\rightarrow(b=1):\\\quad
f(\mathit{pos},\mathit{this},a,1,c)=\sum_jf(\mathit{pos}-1,j,a,0/1,c)-f(\mathit{pos}-1,\mathit{this},a,0/1,c)\\\\
\mathit{if}\space s_{\mathit{pos}}\in[\texttt{0},\texttt{1}]\rightarrow(c=1):\\\quad
f(\mathit{pos},\mathit{this},a,b,1)=\sum_jf(\mathit{pos}-1,j,a,b,0/1)-f(\mathit{pos}-1,\mathit{this},a,b,0/1)\\\\
\mathit{if}\space s_{\mathit{pos}}=\texttt{?}:\\
\quad\Rightarrow[\texttt{a},\texttt{z}]:\sum_{i\in[\texttt{a},\texttt{z}]}\Big(\sum_jf(\mathit{pos}-1,j,0/1,b,c)-f(\mathit{pos}-1,i,0/1,b,c)\Big)\\
\quad\Rightarrow[\texttt{A},\texttt{Z}]:\sum_{i\in[\texttt{A},\texttt{Z}]}\Big(\sum_jf(\mathit{pos}-1,j,a,0/1,c)-f(\mathit{pos}-1,i,a,0,1,c)\Big)\\
\quad\Rightarrow[\texttt{0},\texttt{9}]:\sum_{i\in[\texttt{0},\texttt{9}]}\Big(\sum_jf(\mathit{pos}-1,j,a,b,0/1)-f(\mathit{pos}-1,i,a,b,0/1)\Big)
\end{array}
$$

其实就是，对于每一个 `?`，都需要从上一维的每一个（排除三个情况）状态转移，那我们可以记录上一维的总和，转移的时候减去特殊的三个即可。

## 代码

```cpp
#include <bits/stdc++.h>

using std::cin;
using std::string;

using ll = long long;
const ll MOD = 998244353;

const int to[256] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                     52, 53, 54, 55, 56, 57, 58, 59, 60, 61,   0, 0,
                     0,  0,  0,  0,  0,  26, 27, 28, 29, 30, 31, 32,
                     33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
                     45, 46, 47, 48, 49, 50, 51, 0,  0,  0, 0, 0, 0,
                     0, 1, 2, 3,  4, 5, 6, 7, 8,  9, 10, 11, 12, 13,
                     14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25};

ll f[2][65][2][2][2], g[2][2][2];

#define rep(i, x) for (int i = 0; i < (x); ++i)
#define gor(i, l, r) for (int i = (l); i < (r); ++i)

#define _r_ab rep(a, 2) rep(b, 2)
#define _r_ac rep(a, 2) rep(c, 2)
#define _r_bc rep(b, 2) rep(c, 2)
#define _r_abc rep(a, 2) rep(b, 2) rep(c, 2)

#define ths to[sp]
#define ff f[pos][now]
#define f0 f[pos ^ 1][now]

#define add(x, a) (x += (a) % MOD) %= MOD
#define sub(x, a) (x = x - (a) % MOD + MOD) %= MOD
#define as2(x, a, b) add(x, a), sub(x, b)

#define _ab(x) x[a][b][0] + x[a][b][1]
#define _ac(x) x[a][0][c] + x[a][1][c]
#define _bc(x) x[0][b][c] + x[1][b][c]
#define _abc(x) x[a][b][c]

#define lw(x) islower(x)
#define up(x) isupper(x)
#define dg(x) isdigit(x)

inline void do_lw(int pos, int now) {
    _r_bc as2(ff[1][b][c], _bc(g), _bc(f0));
} inline void do_up(int pos, int now) {
    _r_ac as2(ff[a][1][c], _ac(g), _ac(f0));
} inline void do_dg(int pos, int now) {
    _r_ab as2(ff[a][b][1], _ab(g), _ab(f0));
}

inline void init(int s0) {
    if (lw(s0)) f[0][to[s0]][1][0][0] = 1, f[0][to[s0] + 26][0][1][0] = 1;
    else if (up(s0)) f[0][to[s0]][0][1][0] = 1;
    else if (dg(s0)) f[0][to[s0]][0][0][1] = 1;
    else {
        rep(i, 26) f[0][to[i + 'a']][1][0][0] = 1;
        rep(i, 26) f[0][to[i + 'A']][0][1][0] = 1;
        rep(i, 10) f[0][to[i + '0']][0][0][1] = 1;
    }
}

inline void calc(int pos, int sp) {
    _r_abc { _abc(g) = 0; rep(now, 62) _abc(ff) = 0, add(_abc(g), _abc(f0)); }
    if (lw(sp)) do_lw(pos, ths), do_up(pos, ths + 26);
    else if (up(sp)) do_up(pos, ths);
    else if (dg(sp)) do_dg(pos, ths);
    else {
        gor(now,  0, 26) do_lw(pos, now);
        gor(now, 26, 52) do_up(pos, now);
        gor(now, 52, 62) do_dg(pos, now);
    }
}

ll solve(int n, string str) {
    init(str[0]); int j = 1;
    for (int pos = 1; pos < n; ++pos, j ^= 1) calc(j, str[pos]); 
    ll res = 0; rep(i, 62) (res += f[j ^ 1][i][1][1][1]) %= MOD;
    return res;
}

signed main() {
    std::ios::sync_with_stdio(false); cin.tie(nullptr);
    int n; string str; cin >> n >> str;
    printf("%lld\n", solve(n, str));
    return 0;
}
```
