---
title: P9754 [CSP-S 2023] 结构体 做题记录
date: 1710411660
description: 第 740 通过！费了好大的劲。我的码力还是不够呀。

首先，我们将所有操作抽象为两个结构。

一个是类型（Type）结构，一个是变量（Var）结构。

其中，类型结构包含了类型的增加，没了。

主要的操作集中在变量上，主要是变量的创建和地址的访问。

author: 371511
---

第 $740$ 通过！费了好大的劲。我的码力还是不够呀。

首先，我们将所有操作抽象为两个结构。

一个是类型（Type）结构，一个是变量（Var）结构。

其中，类型结构包含了类型的增加，没了。

主要的操作集中在变量上，主要是变量的创建和地址的访问。

于是考虑将这两块分开处理，然后，其实也不需要合在一起。

我们先实现类型的增加，只需要同步记录这个类型的所有信息（没用的可以不记）即可。

对于对齐的问题，CCF 给的形象化题面一点也不形象，甚至说有很大的误导。

比如本人就是没有理解题意，导致了考场上特殊性质都没拿全。

推荐这个文章：<https://blog.csdn.net/whahu1989/article/details/123455201>。

主要的问题集中在结构体对齐上，题目里没有说明的：

一个结构体的大小需要是对齐要求的整数倍，

**而变量在结构体内的对齐仅仅是对于结构体的开端对齐的**。

然后多加几个 `unordered_map` 和 `map` 就行了（？）

只要我们信息记录的足够全面，就一定能求解出每一个答案。

注意查询操作都需要递归（其实是递推）的处理，但是没有分支，直接 `while (1)` 就行。

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

inline ll getAlign(ll pool, int Align) {
    return ceil(pool * 1.0 / Align) * Align;
}

struct Var {
    string type, name; ll addr;
};

struct Type {
    vector<Var> Member;
    map<ll, string> addr;
    unordered_map<string, int> oPs;
    ll Size, Align;
    Type() = default;
    Type(ll def): Size(def), Align(def) {}
    Type(ll size, ll align): Size(size), Align(align) {}
};

unordered_map<string, Type> getType = {
    {"byte",  Type(1)},
    {"short", Type(2)},
    {"int",   Type(4)},
    {"long",  Type(8)}
};

ll Pool = 0;

map<ll, string> op4;
unordered_map<string, pair<string, ll>> op3;

void insertType() {
    string name; int k; Type type;
    cin >> name >> k; type.Member.resize(k);
    ll pool = 0, align = -1;
    string tp, nm; for (int i = 0; i < k; ++i) {
        cin >> tp >> nm; ll s = getType[tp].Align;
        pool = getAlign(pool, s), align = max(align, s);
        type.oPs[nm] = i; type.addr[pool] = nm;
        type.Member[i].type = tp, type.Member[i].name = nm;
        type.Member[i].addr = pool, pool += getType[tp].Size;
    } pool = getAlign(pool, align);
    type.Size = pool, type.Align = align;
    cout << pool << " " << align << endl;
    return void(getType[name] = type);
}

void insertVar() {
    string type, name; cin >> type >> name;
    ll beg = getType[type].Align;
    Pool = getAlign(Pool, beg); cout << Pool << endl;
    op3[name] = {type, Pool}, op4[Pool] = name;
    Pool += getType[type].Size;
}

void getAddr() {
    string vr; cin >> vr; vr = vr + ".";
    vector<string> opq; string base;
    for (char c : vr) if (c != '.') base.push_back(c);
    else opq.push_back(base), base = "";
    string now = op3[opq[0]].first; ll addr = op3[opq[0]].second;
    for (int i = 1; i < opq.size(); ++i) {
        string name = opq[i];
        addr += getType[now].Member[getType[now].oPs[name]].addr;
        now = getType[now].Member[getType[now].oPs[name]].type;
    } cout << addr << endl;
}

void getName() {
    ll addr; cin >> addr;
    auto it1 = op4.upper_bound(addr);
    if (it1 == op4.begin()) return void(cout << "ERR" << endl);
    string ans = (--it1)->second;
    string now = op3[ans].first;
    addr -= it1->first; while (1) {
        auto t = getType[now];
        if (t.addr.size() == 0) break;
        auto it2 = t.addr.upper_bound(addr);
        if (it2 == t.addr.begin()) return void(cout << "ERR" << endl);
        ans += "." + (--it2)->second, addr -= it2->first;
        now = t.Member[t.oPs[it2->second]].type;
    } if (addr >= getType[now].Size) cout << "ERR" << endl;
    else cout << ans << endl;
}

void action(int op) {
    if (op == 1) insertType(); if (op == 2) insertVar();
    if (op == 3) getAddr();    if (op == 4) getName();
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr);
    int n, op; cin >> n; while (n--) cin >> op, action(op);
    return 0;
}
```

轻微压行，刚好 $100$ 行。
